<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/all.min.css" integrity="sha256-AbA177XfpSnFEvgpYu1jMygiLabzPCJCRIBtR5jGc0k=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.13.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":{"enable":true,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="Gray&#39;s Blog">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Gray&#39;s Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Wang Wenhui">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Gray's Blog</title>
  






  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>


<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Gray's Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Wang Wenhui</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">43</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/07/06/STL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Wang Wenhui">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gray's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Gray's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/07/06/STL/" class="post-title-link" itemprop="url">STL</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-07-06 21:30:56 / 修改时间：22:00:35" itemprop="dateCreated datePublished" datetime="2023-07-06T21:30:56+08:00">2023-07-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CPP/" itemprop="url" rel="index"><span itemprop="name">CPP</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
	<div>
		
	</div>
    <div class="post-body" itemprop="articleBody">
          <h1 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h1><p>STL全称为Standard Template Library，即标准模板库。	</p>
<p>带给我们<em><strong>泛型编程</strong></em>的思想，即实现可重用、通用的代码。</p>
<p>STL提供了六大组件：</p>
<ol>
<li>容器：各种数据结构，可以看成是class template</li>
<li>算法：各种常用算法，sort，copy等，可以看成是function template</li>
<li>迭代器：泛型指针，重载指针相关操作</li>
<li>仿函数：重载了operator()的class</li>
<li>适配器：修饰容器或仿函数或迭代器接口的东西，类似于容器，但底层是由其他容器实现的。</li>
<li>配置器：负责空间配置与管理，是一个实现了管理内存空间的class template</li>
</ol>
<p>STL的序列式容器有以下几个</p>
<ol>
<li>array数组（内置）</li>
<li>vector (heap) (priority_queue)</li>
<li>list</li>
<li>slist</li>
<li>deque (stack) (queue)</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/06/29/copy-on-write/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Wang Wenhui">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gray's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Gray's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/06/29/copy-on-write/" class="post-title-link" itemprop="url">copy-on-write</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-06-29 16:16:33" itemprop="dateCreated datePublished" datetime="2023-06-29T16:16:33+08:00">2023-06-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-08-13 15:51:12" itemprop="dateModified" datetime="2023-08-13T15:51:12+08:00">2023-08-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/6-S081-Lab/" itemprop="url" rel="index"><span itemprop="name">6.S081 Lab</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
	<div>
		
	</div>
    <div class="post-body" itemprop="articleBody">
          <h2 id="Implement-copy-on-write-fork-hard"><a href="#Implement-copy-on-write-fork-hard" class="headerlink" title="Implement copy-on-write fork(hard)"></a>Implement copy-on-write fork(<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.S081/2022/labs/guidance.html">hard</a>)</h2><p>要求我们实现一个写时复制，本来的fork调用直接将父进程的内存复制到子进程中，但通常情况下子进程会执行exec，会丢弃复制的内存，也就是说之前的复制是没意义的。现在我们要做的是在真正需要的时候才完成复制。</p>
<p>根据课程网站上的信息一步一步来</p>
<p>首先在riscv.h中添加一个标志位</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_V (1L &lt;&lt; 0) <span class="comment">// valid</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_R (1L &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_W (1L &lt;&lt; 2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_X (1L &lt;&lt; 3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_U (1L &lt;&lt; 4) <span class="comment">// user can access</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_C (1L &lt;&lt; 8)</span></span><br><span class="line"><span class="comment">// PTE_C标记一个页面是否为c-o-w fork页面</span></span><br></pre></td></tr></table></figure>

<p>然后定义一个操作内存的锁，因为一开始并不分配页面，而是将同一个内存映射到两个进程里，所以同步引用计数的时候需要用到锁。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里的cnt代表当前页面被引用了几次</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ref_stru</span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">spinlock</span> lock;</span><br><span class="line">  <span class="type">int</span> cnt[(PHYSTOP - KERNBASE)/PGSIZE];</span><br><span class="line">&#125; ref;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">kinit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">initlock</span>(&amp;kmem.lock, <span class="string">&quot;kmem&quot;</span>);</span><br><span class="line">  <span class="built_in">initlock</span>(&amp;ref.lock, <span class="string">&quot;ref&quot;</span>);</span><br><span class="line">  <span class="built_in">freerange</span>(end, (<span class="type">void</span>*)PHYSTOP);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后定义几个接口封装一下，这样在别的函数中调用更方便，当然这不是封装的优点不止这个</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">acquire_lock</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">acquire</span>(&amp;ref.lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">release_lock</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">release</span>(&amp;ref.lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ref_set</span><span class="params">(uint64 pa, <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">  ref.cnt[(pa - KERNBASE) / PGSIZE] = n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ref_get</span><span class="params">(uint64 pa)</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> n = ref.cnt[(pa - KERNBASE) / PGSIZE];</span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ref_add</span><span class="params">(uint64 pa, <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">  ref.cnt[(pa - KERNBASE) / PGSIZE] += n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后修改kfree和kalloc</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kalloc初始化的时候计数设为1</span></span><br><span class="line"><span class="function"><span class="type">void</span> *</span></span><br><span class="line"><span class="function"><span class="title">kalloc</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">run</span> *r;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">acquire</span>(&amp;kmem.lock);</span><br><span class="line">  r = kmem.freelist;</span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    kmem.freelist = r-&gt;next;</span><br><span class="line">  <span class="built_in">release</span>(&amp;kmem.lock);</span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//acquire(&amp;ref.lock);</span></span><br><span class="line">    ref.cnt[((uint64)r - KERNBASE) / PGSIZE] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//release(&amp;ref.lock);</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    <span class="built_in">memset</span>((<span class="type">char</span>*)r, <span class="number">5</span>, PGSIZE); <span class="comment">// fill with junk</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span>*)r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kfree每次被调用都将引用记数递减，只有减到0才将内存清空</span></span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">kfree</span><span class="params">(<span class="type">void</span> *pa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">run</span> *r;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(((uint64)pa % PGSIZE) != <span class="number">0</span> || (<span class="type">char</span>*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;kfree&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">acquire</span>(&amp;ref.lock);</span><br><span class="line">  <span class="keyword">if</span>(--ref.cnt[((uint64)pa-KERNBASE)/PGSIZE] == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">release</span>(&amp;ref.lock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Fill with junk to catch dangling refs.</span></span><br><span class="line">    <span class="built_in">memset</span>(pa, <span class="number">1</span>, PGSIZE);</span><br><span class="line">    </span><br><span class="line">    r = (<span class="keyword">struct</span> run*)pa;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">acquire</span>(&amp;kmem.lock);</span><br><span class="line">    r-&gt;next = kmem.freelist;</span><br><span class="line">    kmem.freelist = r;</span><br><span class="line">    <span class="built_in">release</span>(&amp;kmem.lock);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">release</span>(&amp;ref.lock);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在添加几个函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断一个页面是否是c-o-w页面，是就返回0</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cowpage</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (va &gt;= MAXVA)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="type">pte_t</span>* pte = <span class="built_in">walk</span>(pagetable, va, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (pte == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span> ((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> (*pte &amp; PTE_C ? <span class="number">0</span> : <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分配页面</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">cowalloc</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (va % PGSIZE != <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  uint64 pa = <span class="built_in">walkaddr</span>(pagetable, va);</span><br><span class="line">  <span class="keyword">if</span> (pa == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">pte_t</span>* pte = <span class="built_in">walk</span>(pagetable, va, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">ref_get</span>((uint64)pa) == <span class="number">1</span>) &#123;</span><br><span class="line">    *pte |= PTE_W;</span><br><span class="line">    *pte &amp;= ~PTE_C;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>*)pa;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="type">char</span>* mem = <span class="built_in">kalloc</span>();</span><br><span class="line">    <span class="keyword">if</span> (mem == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memmove</span>(mem, (<span class="type">char</span>*)pa, PGSIZE);</span><br><span class="line"></span><br><span class="line">    *pte &amp;= ~PTE_V;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">mappages</span>(pagetable, va, PGSIZE, (uint64)mem, (<span class="built_in">PTE_FLAGS</span>(*pte) | PTE_W) &amp; ~PTE_C) != <span class="number">0</span> ) &#123;</span><br><span class="line">      <span class="built_in">kfree</span>(mem);</span><br><span class="line">      *pte |= PTE_V;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">kfree</span>((<span class="type">char</span>*)<span class="built_in">PGROUNDDOWN</span>(pa));</span><br><span class="line">    <span class="keyword">return</span> mem;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// copy页面，这里的cowcopy其实就是cowpage+cowalloc，我参考了两个同学的博客，他们的思路不太一样，我就两个都理解并尝试了一下</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cowcopy</span><span class="params">(uint64 va)</span></span>&#123;</span><br><span class="line">  va = <span class="built_in">PGROUNDDOWN</span>(va);</span><br><span class="line">  <span class="type">pagetable_t</span> p = <span class="built_in">myproc</span>()-&gt;pagetable;</span><br><span class="line">  <span class="type">pte_t</span>* pte = <span class="built_in">walk</span>(p, va, <span class="number">0</span>);</span><br><span class="line">  uint64 pa = <span class="built_in">PTE2PA</span>(*pte);</span><br><span class="line">  uint flags = <span class="built_in">PTE_FLAGS</span>(*pte);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(!(flags &amp; PTE_C)) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;not cow\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">acquire_lock</span>();</span><br><span class="line">  uint count = <span class="built_in">ref_get</span>(pa);</span><br><span class="line">  <span class="keyword">if</span> (count &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="type">char</span>* mem = <span class="built_in">kalloc</span>();</span><br><span class="line">    <span class="keyword">if</span> (mem == <span class="number">0</span>) </span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    <span class="built_in">memmove</span>(mem,(<span class="type">char</span>*)pa,PGSIZE);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">mappages</span>(p, va, PGSIZE, (uint64)mem, (flags &amp; (~PTE_C)) | PTE_W) != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">kfree</span>(mem);</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">ref_add</span>(pa,<span class="number">-1</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    *pte = ((*pte) &amp; (~PTE_C)) | PTE_W;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">release_lock</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  bad:</span><br><span class="line">  <span class="built_in">release_lock</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后是freerange,在kinit中会调用freerange，接着调用kfeee，如果在freerange里不置1的话，kfree里会减为-1</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">freerange</span><span class="params">(<span class="type">void</span> *pa_start, <span class="type">void</span> *pa_end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">char</span> *p;</span><br><span class="line">  p = (<span class="type">char</span>*)<span class="built_in">PGROUNDUP</span>((uint64)pa_start);</span><br><span class="line">  <span class="keyword">for</span>(; p + PGSIZE &lt;= (<span class="type">char</span>*)pa_end; p += PGSIZE) &#123;</span><br><span class="line">    <span class="built_in">ref_set</span>((uint64)p, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">kfree</span>(p);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着是uvmcopy，这里将原来的分配内存改为将父进程中页表映射到子进程中，两个地址指向同一个物理地址，同时将读写权限关掉，将PTE_C置为1，代表这是c-o-w页面</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">uvmcopy</span><span class="params">(<span class="type">pagetable_t</span> old, <span class="type">pagetable_t</span> <span class="keyword">new</span>, uint64 sz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line">  uint64 pa, i;</span><br><span class="line">  uint flags;</span><br><span class="line">  <span class="comment">//char *mem;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; sz; i += PGSIZE)&#123;</span><br><span class="line">    <span class="keyword">if</span>((pte = <span class="built_in">walk</span>(old, i, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">      <span class="built_in">panic</span>(<span class="string">&quot;uvmcopy: pte should exist&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">      <span class="built_in">panic</span>(<span class="string">&quot;uvmcopy: page not present&quot;</span>);</span><br><span class="line">    pa = <span class="built_in">PTE2PA</span>(*pte);</span><br><span class="line">    flags = <span class="built_in">PTE_FLAGS</span>(*pte);</span><br><span class="line"></span><br><span class="line">    *pte = ((*pte) &amp; (~PTE_W)) | PTE_C;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if((mem = kalloc()) == 0)</span></span><br><span class="line">    <span class="comment">//   goto err;</span></span><br><span class="line">    <span class="comment">// memmove(mem, (char*)pa, PGSIZE);</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">mappages</span>(<span class="keyword">new</span>, i, PGSIZE, (uint64)pa, (flags &amp; (~PTE_W)) | PTE_C) != <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">//kfree(mem);</span></span><br><span class="line">      <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">ref_add</span>(pa,<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> err:</span><br><span class="line">  <span class="built_in">uvmunmap</span>(<span class="keyword">new</span>, <span class="number">0</span>, i / PGSIZE, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在usertrap里处理页面错误，这里就是加了一个r_scause() &#x3D;&#x3D; 15的判断，说明这里子进程的页面被访问了，所以要给他分配内存，不能用原来父进程的内存了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">r_scause</span>() == <span class="number">8</span>)&#123;</span><br><span class="line">  <span class="comment">// system call</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">killed</span>(p))</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// sepc points to the ecall instruction,</span></span><br><span class="line">  <span class="comment">// but we want to return to the next instruction.</span></span><br><span class="line">  p-&gt;trapframe-&gt;epc += <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// an interrupt will change sepc, scause, and sstatus,</span></span><br><span class="line">  <span class="comment">// so enable only now that we&#x27;re done with those registers.</span></span><br><span class="line">  <span class="built_in">intr_on</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">syscall</span>();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">r_scause</span>() == <span class="number">15</span>) &#123;</span><br><span class="line">  uint64 va = <span class="built_in">r_stval</span>();</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">cowcopy</span>(va) == <span class="number">-1</span>) &#123;</span><br><span class="line">    p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>((which_dev = <span class="built_in">devintr</span>()) != <span class="number">0</span>)&#123;</span><br><span class="line">  <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>

<p>最后在copyout中处理相同的情况</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">copyout</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 dstva, <span class="type">char</span> *src, uint64 len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  uint64 n, va0, pa0;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    va0 = <span class="built_in">PGROUNDDOWN</span>(dstva);</span><br><span class="line">    pa0 = <span class="built_in">walkaddr</span>(pagetable, va0);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里如果判读是cow页面的话，则分配一个独立的内存</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">cowpage</span>(pagetable, va0) == <span class="number">0</span>) &#123;</span><br><span class="line">      pa0 = (uint64)<span class="built_in">cowalloc</span>(pagetable, va0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pa0 == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    n = PGSIZE - (dstva - va0);</span><br><span class="line">    <span class="keyword">if</span>(n &gt; len)</span><br><span class="line">      n = len;</span><br><span class="line">    <span class="built_in">memmove</span>((<span class="type">void</span> *)(pa0 + (dstva - va0)), src, n);</span><br><span class="line"></span><br><span class="line">    len -= n;</span><br><span class="line">    src += n;</span><br><span class="line">    dstva = va0 + PGSIZE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写这个代码的时候，遇到过锁相关的问题，一开始封装接口的时候，在操作计数前后加上了锁的获取和释放，但实际上函数在调用这些接口前，就可能已经获取锁了，如果接口里仍然获取锁的话，就会导致一个自旋锁的锁重入问题，从而发生死锁。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/06/25/traps/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Wang Wenhui">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gray's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Gray's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/06/25/traps/" class="post-title-link" itemprop="url">traps</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-06-25 16:37:44" itemprop="dateCreated datePublished" datetime="2023-06-25T16:37:44+08:00">2023-06-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-08-11 15:59:50" itemprop="dateModified" datetime="2023-08-11T15:59:50+08:00">2023-08-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/6-S081-Lab/" itemprop="url" rel="index"><span itemprop="name">6.S081 Lab</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
	<div>
		
	</div>
    <div class="post-body" itemprop="articleBody">
          <p>这个实验是让我们熟悉陷阱（trap）的</p>
<h2 id="Backtrace-moderate"><a href="#Backtrace-moderate" class="headerlink" title="Backtrace (moderate)"></a>Backtrace (<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.S081/2022/labs/guidance.html">moderate</a>)</h2><p>要求我们实现一个获取回溯信息的函数。</p>
<p>课程网站上给的信息足够多，写出来还是比较简单的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加到printf.c文件中</span></span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">backtrace</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;backtrace:\n&quot;</span>);</span><br><span class="line">  uint64 fp = <span class="built_in">r_fp</span>();</span><br><span class="line">  uint64 base = <span class="built_in">PGROUNDUP</span>(fp);</span><br><span class="line">  <span class="keyword">while</span> (fp &lt; base) &#123; 	<span class="comment">//判断是否超过一整页了</span></span><br><span class="line">    uint64 ret_addr = *(uint64*)(fp - <span class="number">8</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, ret_addr);</span><br><span class="line">    fp = *(uint64*)(fp - <span class="number">16</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>网站告诉我们GCC编译器将当前执行函数的帧指针存储在寄存器s0中。在kernel&#x2F;riscv.h中添加以下函数：<code> static inline uint64 r_fp() &#123; uint64 x; asm volatile(&quot;mv %0, s0&quot; : &quot;=r&quot; (x) ); return x; &#125;</code>，所以<code>r_fp()</code>就可以获得帧指针。</p>
<h2 id="Alarm-hard"><a href="#Alarm-hard" class="headerlink" title="Alarm (hard)"></a>Alarm (<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.S081/2022/labs/guidance.html">hard</a>)</h2><p>这个实验我们需要为xv6添加一个功能，当进程使用CPU时间时定期向其发出警报。添加两个系统调用，一个是sigalarm，另一个是sigreturn。</p>
<p>首先<code>struct proc</code>结构体中要加入几个字段。 还要在初始化和释放。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> alarm_interval; <span class="comment">//每次转动n次执行</span></span><br><span class="line"><span class="built_in">void</span> (*alarm_handler)(); <span class="comment">//处理函数</span></span><br><span class="line"><span class="type">int</span> count; <span class="comment">//当前转过的次数</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> isalarm; <span class="comment">//当前是否已经在另一个处理中了</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">trapframe</span>* alarm_trapframe; <span class="comment">//用来保存当前的trapframe</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//allocproc()中初始化</span></span><br><span class="line">p-&gt;alarm_interval = <span class="number">0</span>;</span><br><span class="line">p-&gt;alarm_handler = <span class="number">0</span>;</span><br><span class="line">p-&gt;count = <span class="number">0</span>;</span><br><span class="line">p-&gt;isalarm = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>((p-&gt;alarm_trapframe = (<span class="keyword">struct</span> trapframe *)<span class="built_in">kalloc</span>()) == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">freeproc</span>(p);</span><br><span class="line">    <span class="built_in">release</span>(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//freeproc()中释放</span></span><br><span class="line"><span class="keyword">if</span>(p-&gt;alarm_trapframe)</span><br><span class="line">    <span class="built_in">kfree</span>((<span class="type">void</span>*)p-&gt;alarm_trapframe);</span><br><span class="line">p-&gt;alarm_trapframe = <span class="number">0</span>;</span><br><span class="line">p-&gt;alarm_interval = <span class="number">0</span>;</span><br><span class="line">p-&gt;alarm_handler = <span class="number">0</span>;</span><br><span class="line">p-&gt;count = <span class="number">0</span>;</span><br><span class="line">p-&gt;isalarm = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>然后就是两个系统调用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uint64</span></span><br><span class="line"><span class="function"><span class="title">sys_sigalarm</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">// 传参</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> tick;</span><br><span class="line">  <span class="built_in">void</span> (*handler)();</span><br><span class="line">  <span class="built_in">argint</span>(<span class="number">0</span>,&amp;tick);</span><br><span class="line">  <span class="keyword">if</span> (tick &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="built_in">argaddr</span>(<span class="number">1</span>,(uint64*)&amp;handler);</span><br><span class="line">  <span class="keyword">if</span> (handler &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">proc</span>* p = <span class="built_in">myproc</span>();</span><br><span class="line">  p-&gt;alarm_interval = tick;</span><br><span class="line">  p-&gt;alarm_handler = handler;</span><br><span class="line">  <span class="comment">// p-&gt;alarm_interval = 0;</span></span><br><span class="line">  <span class="comment">// p-&gt;alarm_trapframe = 0;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">uint64</span></span><br><span class="line"><span class="function"><span class="title">sys_sigreturn</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">// 用来恢复trapframe</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">memmove</span>(<span class="built_in">myproc</span>()-&gt;trapframe, <span class="built_in">myproc</span>()-&gt;alarm_trapframe, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> trapframe));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>usertrap中要修改的是时间中断的过程</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line"><span class="keyword">if</span>(which_dev == <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;alarm_interval != <span class="number">0</span> &amp;&amp; ++p-&gt;count == p-&gt;alarm_interval &amp;&amp; p-&gt;isalarm == <span class="number">0</span>) &#123; </span><br><span class="line">        <span class="comment">//判断条件是alarm_interval没被设为0且计数到了alarm_interval</span></span><br><span class="line">        <span class="comment">//且这个时候没有在alarm中</span></span><br><span class="line">        <span class="built_in">memmove</span>(p-&gt;alarm_trapframe, p-&gt;trapframe, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> trapframe));</span><br><span class="line">        p-&gt;trapframe-&gt;epc = (uint64)p-&gt;alarm_handler;</span><br><span class="line">        p-&gt;count = <span class="number">0</span>;</span><br><span class="line">        p-&gt;isalarm = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">yield</span>();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/25/pagetable%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Wang Wenhui">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gray's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Gray's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/25/pagetable%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/" class="post-title-link" itemprop="url">pagetable源码阅读</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-25 23:10:42" itemprop="dateCreated datePublished" datetime="2023-04-25T23:10:42+08:00">2023-04-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-05-06 16:52:17" itemprop="dateModified" datetime="2023-05-06T16:52:17+08:00">2023-05-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/6-S081-Lab/" itemprop="url" rel="index"><span itemprop="name">6.S081 Lab</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
	<div>
		
	</div>
    <div class="post-body" itemprop="articleBody">
          <p>关于页表的内容是比较难的，光是看课程有些晦涩难懂，做实验也需要充分理解代码中的许多内容，所以就先阅读一下实验前置的一些代码。</p>
<h2 id="kernel-x2F-memlayout-h"><a href="#kernel-x2F-memlayout-h" class="headerlink" title="kernel&#x2F;memlayout.h"></a>kernel&#x2F;memlayout.h</h2><p>首先看这个文件，开头是注释<code>// Physical memory layout</code>，说明这是关于物理内存布局的，第二段的注释也大致说了一下内存分布。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// qemu puts UART registers here in physical memory.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UART0 0x10000000L</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UART0_IRQ 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// virtio mmio interface</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VIRTIO0 0x10001000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VIRTIO0_IRQ 1</span></span><br></pre></td></tr></table></figure>

<p>两段第一个宏定义解释了两个寄存器在物理内存中的位置，两段第二个宏定义是有关中断的，IRQ应该是Interrupt Request中断请求信号，分别表示UART0设备产生中断时，中断请求号为10，VIRTIO0则为1。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// core local interruptor (CLINT), which contains the timer.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLINT 0x2000000L</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLINT_MTIMECMP(hartid) (CLINT + 0x4000 + 8*(hartid))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLINT_MTIME (CLINT + 0xBFF8) <span class="comment">// cycles since boot.</span></span></span><br></pre></td></tr></table></figure>

<p>上面的代码定义了core local interruptor的位置，即为0x2000000。<br>第二个宏定义起到了类似函数的作用，将hartid作为参数传入，计算出hartid对应的mtimecmp寄存器的地址。<br>第三个宏定义则是指定mtime寄存器的地址，即为CLINT基地址+偏移量0xBFF8。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// qemu puts platform-level interrupt controller (PLIC) here.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLIC 0x0c000000L</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLIC_PRIORITY (PLIC + 0x0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLIC_PENDING (PLIC + 0x1000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLIC_MENABLE(hart) (PLIC + 0x2000 + (hart)*0x100)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLIC_SENABLE(hart) (PLIC + 0x2080 + (hart)*0x100)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLIC_MPRIORITY(hart) (PLIC + 0x200000 + (hart)*0x2000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLIC_SPRIORITY(hart) (PLIC + 0x201000 + (hart)*0x2000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLIC_MCLAIM(hart) (PLIC + 0x200004 + (hart)*0x2000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLIC_SCLAIM(hart) (PLIC + 0x201004 + (hart)*0x2000)</span></span><br></pre></td></tr></table></figure>

<p>这段代码定义了有关PLIC寄存器的一些内容，PLIC是管理外部中断信号的寄存器。<br>首先是基地址，然后是全局中断优先级寄存器(PLIC_PRIORITY)的地址,然后是中断挂起寄存器(PLIC_PENDING)地址。<br>接着是6个类函数定义，依次表示<br>PLIC 的每个处理器核心的全局使能寄存器地址，<br>PLIC 的每个处理器核心的本地（特定于核心的）使能寄存器地址，<br>PLIC 的每个处理器核心的全局中断优先级寄存器地址，<br>PLIC 的每个处理器核心的本地（特定于核心的）中断优先级寄存器地址，<br>PLIC 的每个处理器核心的全局中断声明寄存器地址，<br>PLIC 的每个处理器核心的本地（特定于核心的）中断声明寄存器地址。</p>
<p>这段跟页表没有特别相关，可以先略过，后面讲中断的时候应该会说到这些寄存器的具体作用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// the kernel expects there to be RAM</span></span><br><span class="line"><span class="comment">// for use by the kernel and user pages</span></span><br><span class="line"><span class="comment">// from physical address 0x80000000 to PHYSTOP.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERNBASE 0x80000000L</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PHYSTOP (KERNBASE + 128*1024*1024)</span></span><br></pre></td></tr></table></figure>

<p>这段注释很显然，定义了内核起始地址0x80000000，可用于内核和用户页的最大地址，即基地址+128MB空间。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// map the trampoline page to the highest address,</span></span><br><span class="line"><span class="comment">// in both user and kernel space.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRAMPOLINE (MAXVA - PGSIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// map kernel stacks beneath the trampoline,</span></span><br><span class="line"><span class="comment">// each surrounded by invalid guard pages.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KSTACK(p) (TRAMPOLINE - (p)*2*PGSIZE - 3*PGSIZE)</span></span><br></pre></td></tr></table></figure>

<p>第一个定义将<code>TRAMPOLINE</code>页面映射到最高地址，<code>TRAMPOLINE</code>是一个特殊的页面，用于实现在用户态和内核态之间切换。发生转换时，它会用一些预定义好的寄存器保存当前用户态下的程序执行状态，然后将控制权移交给内核。<br>所以这个页面会被映射到每个进程的用户空间和内核空间。<br><code>MAXVA</code>是一个宏定义，映射了虚拟空间最大地址，<code>\#define MAXVA (1L &lt;&lt; (9 + 9 + 9 + 12 - 1))</code>，<code>(MAXVA - PGSIZE)</code>给它预留了一个页面的大小。</p>
<p>第二个定义映射了kernel stack的地址，p是线程编号，表示是第几个内核线程，每个kstack有一个页存信息，一个页用来作为Guardpage，所以有<code>p*2*PGSIZE</code>。后面的3*PGSIZE是代入0时，要初始分配三个页面，第一个kstack0，顶部和尾部的Guardpage。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// User memory layout.</span></span><br><span class="line"><span class="comment">// Address zero first:</span></span><br><span class="line"><span class="comment">//   text</span></span><br><span class="line"><span class="comment">//   original data and bss</span></span><br><span class="line"><span class="comment">//   fixed-size stack</span></span><br><span class="line"><span class="comment">//   expandable heap</span></span><br><span class="line"><span class="comment">//   ...</span></span><br><span class="line"><span class="comment">//   USYSCALL (shared with kernel)</span></span><br><span class="line"><span class="comment">//   TRAPFRAME (p-&gt;trapframe, used by the trampoline)</span></span><br><span class="line"><span class="comment">//   TRAMPOLINE (the same page as in the kernel)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRAPFRAME (TRAMPOLINE - PGSIZE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LAB_PGTBL</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USYSCALL (TRAPFRAME - PGSIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">usyscall</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> pid;  <span class="comment">// Process ID</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>TRAPFRAME是用于保存进程在陷阱(trap)发生时CPU寄存器状态等信息的页面，在TRAMPOLINE下面一个页面。接下来就定义了一个usyscall结构体。</p>
<h2 id="kernel-x2F-vm-c"><a href="#kernel-x2F-vm-c" class="headerlink" title="kernel&#x2F;vm.c"></a>kernel&#x2F;vm.c</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//核心的数据结构和一些宏在riscv.h中</span></span><br><span class="line"><span class="keyword">typedef</span> uint64 *<span class="type">pagetable_t</span>; <span class="comment">// 512 PTEs</span></span><br><span class="line"><span class="keyword">typedef</span> uint64 <span class="type">pte_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGSIZE 4096 <span class="comment">// bytes per page</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGSHIFT 12  <span class="comment">// bits of offset within a page</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// shift a physical address to the right place for a PTE.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PA2PTE(pa) ((((uint64)pa) &gt;&gt; 12) &lt;&lt; 10)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE2PA(pte) (((pte) &gt;&gt; 10) &lt;&lt; 12)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_FLAGS(pte) ((pte) &amp; 0x3FF)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// extract the three 9-bit page table indices from a virtual address.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PXMASK          0x1FF <span class="comment">// 9 bits</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PXSHIFT(level)  (PGSHIFT+(9*(level)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PX(level, va) ((((uint64) (va)) &gt;&gt; PXSHIFT(level)) &amp; PXMASK)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这是核心函数walk函数</span></span><br><span class="line"><span class="comment">// Return the address of the PTE in page table pagetable</span></span><br><span class="line"><span class="comment">// that corresponds to virtual address va.  If alloc!=0,</span></span><br><span class="line"><span class="comment">// create any required page-table pages.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The risc-v Sv39 scheme has three levels of page-table</span></span><br><span class="line"><span class="comment">// pages. A page-table page contains 512 64-bit PTEs.</span></span><br><span class="line"><span class="comment">// A 64-bit virtual address is split into five fields:</span></span><br><span class="line"><span class="comment">//   39..63 -- must be zero.</span></span><br><span class="line"><span class="comment">//   30..38 -- 9 bits of level-2 index.</span></span><br><span class="line"><span class="comment">//   21..29 -- 9 bits of level-1 index.</span></span><br><span class="line"><span class="comment">//   12..20 -- 9 bits of level-0 index.</span></span><br><span class="line"><span class="comment">//    0..11 -- 12 bits of byte offset within the page.</span></span><br><span class="line"><span class="type">pte_t</span> *</span><br><span class="line"><span class="title function_">walk</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, <span class="type">int</span> alloc)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(va &gt;= MAXVA)</span><br><span class="line">    panic(<span class="string">&quot;walk&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> level = <span class="number">2</span>; level &gt; <span class="number">0</span>; level--) &#123;</span><br><span class="line">    <span class="type">pte_t</span> *pte = &amp;pagetable[PX(level, va)];<span class="comment">//get the address of pgt</span></span><br><span class="line">    <span class="keyword">if</span>(*pte &amp; PTE_V) &#123;</span><br><span class="line">      pagetable = (<span class="type">pagetable_t</span>)PTE2PA(*pte);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(!alloc || (pagetable = (<span class="type">pde_t</span>*)kalloc()) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="built_in">memset</span>(pagetable, <span class="number">0</span>, PGSIZE);</span><br><span class="line">      *pte = PA2PTE(pagetable) | PTE_V;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &amp;pagetable[PX(<span class="number">0</span>, va)];<span class="comment">//shift the offset</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先看核心的walk函数，注释也写的比较清楚。<br>先判断有没有超过最大虚拟地址，然后进入3层循环。第一层先从传入的根页表的地址<code>pagetable</code>中找到第一个9位偏移<code>&amp;pagetable[PX(level, va)]</code>对应的PTE，<code>PX (level, va)</code>也给出，即将传入va中取出对应的9bits。然后判断是否有效，有效则将PTE转换为下一级页表的虚拟地址<code>pagetable = (pagetable_t)PTE2PA(*pte)</code>，无效则根据传入的alloc决定是否要为该PTE分配一个页表，并判断分配是否成功。然后继续循环。最后返回一个移除了偏移量的物理地址？即该物理页的基地址？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create PTEs for virtual addresses starting at va that refer to</span></span><br><span class="line"><span class="comment">// physical addresses starting at pa. va and size might not</span></span><br><span class="line"><span class="comment">// be page-aligned. Returns 0 on success, -1 if walk() couldn&#x27;t</span></span><br><span class="line"><span class="comment">// allocate a needed page-table page.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">mappages</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, uint64 size, uint64 pa, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 a, last;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(size == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;mappages: size&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  a = PGROUNDDOWN(va);</span><br><span class="line">  last = PGROUNDDOWN(va + size - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="keyword">if</span>((pte = walk(pagetable, a, <span class="number">1</span>)) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(*pte &amp; PTE_V)</span><br><span class="line">      panic(<span class="string">&quot;mappages: remap&quot;</span>);</span><br><span class="line">    *pte = PA2PTE(pa) | perm | PTE_V;</span><br><span class="line">    <span class="keyword">if</span>(a == last)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    a += PGSIZE;</span><br><span class="line">    pa += PGSIZE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由注释可以看出这个函数是给没分配PTE的页表分配PTE的，整个函数结构由一个死循环构成。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/17/page-tables/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Wang Wenhui">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gray's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Gray's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/17/page-tables/" class="post-title-link" itemprop="url">page tables</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-17 21:10:01" itemprop="dateCreated datePublished" datetime="2023-04-17T21:10:01+08:00">2023-04-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-06-25 16:29:42" itemprop="dateModified" datetime="2023-06-25T16:29:42+08:00">2023-06-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/6-S081-Lab/" itemprop="url" rel="index"><span itemprop="name">6.S081 Lab</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
	<div>
		
	</div>
    <div class="post-body" itemprop="articleBody">
          <p>这个实验是让我们更熟悉页表的</p>
<h2 id="Speed-up-system-calls"><a href="#Speed-up-system-calls" class="headerlink" title="Speed up system calls"></a>Speed up system calls</h2><p>要求我们通过在用户空间和内核之间共享只读数据区域来加速系统调用，在创建进程的时候，映射一个只读页面，存储 一个<code>struct usyscall</code>结构，其中初始化为当前进程的PID，ugetpid系统调用就直接获取这个PID。总的来说比较简单。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是结构体的定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LAB_PGTBL</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USYSCALL (TRAPFRAME - PGSIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">usyscall</span> &#123;</span><br><span class="line">  <span class="type">int</span> pid;  <span class="comment">// Process ID</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个页在每个进程中是独立的，所以应该放在进程的结构体中</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">usyscall</span> *usyscall; <span class="comment">//添加在struct proc中</span></span><br></pre></td></tr></table></figure>

<p>进程被创建的时候会调用<code>allocproc()</code>，所以在函数中进行页的分配</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Allocate a trapframe page.</span></span><br><span class="line"><span class="keyword">if</span>((p-&gt;trapframe = (<span class="keyword">struct</span> trapframe *)<span class="built_in">kalloc</span>()) == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">freeproc</span>(p);</span><br><span class="line"><span class="built_in">release</span>(&amp;p-&gt;lock);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 阅读上面分配trapframe页的代码可以学怎么分配一个页面，照着写就行</span></span><br><span class="line"><span class="keyword">if</span>((p-&gt;usyscall = (<span class="keyword">struct</span> usyscall *)<span class="built_in">kalloc</span>()) == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">freeproc</span>(p);</span><br><span class="line"><span class="built_in">release</span>(&amp;p-&gt;lock);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 记得初始化结构体中的pid为p-&gt;pid</span></span><br><span class="line">p-&gt;usyscall-&gt;pid = p-&gt;pid;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>分配完页以后，还要将映射添加进页表中，这样操作时才能够进行虚拟地址和物理地址之间的转换。映射的部分在<code>proc_pagetable()</code> 中</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// map the trampoline code (for system call return)</span></span><br><span class="line"><span class="comment">// at the highest user virtual address.</span></span><br><span class="line"><span class="comment">// only the supervisor uses it, on the way</span></span><br><span class="line"><span class="comment">// to/from user space, so not PTE_U.</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">mappages</span>(pagetable, TRAMPOLINE, PGSIZE,</span><br><span class="line">            (uint64)trampoline, PTE_R | PTE_X) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">uvmfree</span>(pagetable, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// map the trapframe page just below the trampoline page, for</span></span><br><span class="line"><span class="comment">// trampoline.S.</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">mappages</span>(pagetable, TRAPFRAME, PGSIZE,</span><br><span class="line">            (uint64)(p-&gt;trapframe), PTE_R | PTE_W) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">uvmunmap</span>(pagetable, TRAMPOLINE, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">uvmfree</span>(pagetable, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据上文映射trampoline和trapframe页的代码可以写出来怎么进行映射</span></span><br><span class="line"><span class="comment">// USYSCALL是宏定义的地址	#define USYSCALL (TRAPFRAME - PGSIZE)</span></span><br><span class="line"><span class="comment">// flag PTE_R和PTE_U表示用户态可访问且可读</span></span><br><span class="line"><span class="comment">// 如果失败则解除映射TRAMPOLINE和TRAPFRAME并且free掉pagetable</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">mappages</span>(pagetable, USYSCALL, PGSIZE,</span><br><span class="line">            (uint64)(p-&gt;usyscall), PTE_R | PTE_U) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">uvmunmap</span>(pagetable, TRAMPOLINE, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">uvmunmap</span>(pagetable, TRAPFRAME, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">uvmfree</span>(pagetable, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回收进程的时候这个页面也要回收，在<code>freeproc()</code>中释放就行</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(p-&gt;trapframe)</span><br><span class="line">    <span class="built_in">kfree</span>((<span class="type">void</span>*)p-&gt;trapframe);</span><br><span class="line">p-&gt;trapframe = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参考上文回收trapframe可以写出代码</span></span><br><span class="line"><span class="keyword">if</span>(p-&gt;usyscall)</span><br><span class="line">    <span class="built_in">kfree</span>((<span class="type">void</span>*)p-&gt;usyscall);</span><br><span class="line">p-&gt;usyscall = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>alloc的时候进行分配，则free的时候还需要进行解除映射</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">uvmunmap</span>(pagetable, USYSCALL, <span class="number">1</span>, <span class="number">0</span>); <span class="comment">//添加进proc_freepagetable中就好了</span></span><br></pre></td></tr></table></figure>

<p>思路还是比较明朗的。</p>
<h2 id="Print-a-page-table"><a href="#Print-a-page-table" class="headerlink" title="Print a page table"></a>Print a page table</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> </span><br><span class="line">_vmprint(<span class="type">pagetable_t</span> pagetable, <span class="type">int</span> level)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// every page has 512 PTEs</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++)&#123;</span><br><span class="line">    <span class="type">pte_t</span> pte = pagetable[i];</span><br><span class="line">    <span class="keyword">if</span>(pte &amp; PTE_V) &#123;</span><br><span class="line">      <span class="comment">//valuable</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; level; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j) <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;..&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      uint64 child = PTE2PA(pte);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d: pte %p pa %p\n&quot;</span>, i, pte, child);</span><br><span class="line">      <span class="keyword">if</span>((pte &amp; (PTE_R|PTE_W|PTE_X)) == <span class="number">0</span>) &#123;</span><br><span class="line">        _vmprint((<span class="type">pagetable_t</span>)child, level+<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> </span><br><span class="line"><span class="title function_">vmprint</span><span class="params">(<span class="type">pagetable_t</span> pagetable)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;page table %p\n&quot;</span>, pagetable);</span><br><span class="line">  _vmprint(pagetable,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先最外层循环512次是因为每个页表都有512个PTEs，对每个PTE先看它的有效性，因为有三级页表，所以根据页表等级来打印输出。<br>这里<code>PTE2PA(PTE)</code>是xv6定义的一个宏<code>#define PTE2PA(pte) (((pte) &gt;&gt; 10) &lt;&lt; 12)</code>,这个宏的作用是将PTE转化成PA，先右移10位将标志位全移除，然后左移12位是因为有12位的偏移。<br>接着打印出信息，然后判断是否到了页表的结尾，如果没到就递归调用下一级页表。</p>
<p>此外要在第一个进程运行的时候做这件事，也就是内核刚开始运行的时候，所以在<code>exec()</code>中进程被创建好之后加上<code>if(p-&gt;pid==1) vmprint(p-&gt;pagetable);</code>这样在第一个进程开始时就会开始调用。</p>
<h2 id="Detect-which-pages-have-been-accessed"><a href="#Detect-which-pages-have-been-accessed" class="headerlink" title="Detect which pages have been accessed"></a>Detect which pages have been accessed</h2><p>这个实验要求我们向 xv6 添加一个新功能，该功能通过检查 RISC-V 页表中的访问位来检测和报告已访问的页面信息，以使某些垃圾收集器（自动内存管理的一种形式）受益。所以我们需要先添加一个标志，也就是访问位。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// riscv.h中</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_V (1L &lt;&lt; 0) <span class="comment">// valid</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_R (1L &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_W (1L &lt;&lt; 2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_X (1L &lt;&lt; 3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_U (1L &lt;&lt; 4) <span class="comment">// user can access</span></span></span><br><span class="line"><span class="comment">// 上面是已经用到的一些标志位，我们添上PTE_A(access)，作为是否被访问了的标志</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_A (1L &lt;&lt; 6)</span></span><br></pre></td></tr></table></figure>

<p>需要我们填补系统调用<code>sys_pgaccess</code>中代码，并且查看<code>pgtbltest.c</code>文件可以看到会调用<code>pgaccess()</code>，所以在proc中实现这个函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LAB_PGTBL</span></span><br><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">sys_pgaccess</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// lab pgtbl: your code here.</span></span><br><span class="line">  <span class="comment">// 这个系统调用的作用主要就是读取命令行参数，再把读取到的参数传给pgaccess。</span></span><br><span class="line">  <span class="comment">// 如果参数不满足要求则返回-1，否则返回pgaccess的调用结果</span></span><br><span class="line">  uint64 pg;</span><br><span class="line">  <span class="type">int</span> number;</span><br><span class="line">  uint64 store;</span><br><span class="line">  <span class="built_in">argaddr</span>(<span class="number">0</span>,&amp;pg);</span><br><span class="line">  <span class="keyword">if</span> ( buf &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="built_in">argint</span>(<span class="number">1</span>,&amp;number);</span><br><span class="line">  <span class="keyword">if</span> ( number &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="built_in">argaddr</span>(<span class="number">2</span>,&amp;store);</span><br><span class="line">  <span class="keyword">if</span> ( ans &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">pgaccess</span>((<span class="type">void</span>*)pg, number, (<span class="type">void</span>*)store);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>然后是pgaccess函数,注意要在defs.h中的声明</p>
<p>从实验要求中得知，调用有三个参数。首先，它接收要检查的第一个用户页面的起始虚拟地址。其次，它接收要检查的页面数。最后，它接收用于将结果存储到位掩码中的缓冲区用户地址。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//位于proc.c中</span></span><br><span class="line"><span class="function">uint64</span></span><br><span class="line"><span class="function"><span class="title">pgaccess</span><span class="params">(<span class="type">void</span>* pg, <span class="type">int</span> number, <span class="type">void</span>* store)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">proc</span> *p = <span class="built_in">myproc</span>();</span><br><span class="line">  <span class="keyword">if</span> (p == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">pagetable_t</span> pagetable = p -&gt;pagetable;</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; number; i++) &#123;</span><br><span class="line">    <span class="type">pte_t</span> *pte;</span><br><span class="line">    pte = <span class="built_in">walk</span>(pagetable,((uint64)pg) +(uint64)PGSIZE * i, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (pte != <span class="number">0</span> &amp;&amp; ((*pte) &amp; PTE_A)) &#123;</span><br><span class="line">      ans |= <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">      *pte ^= PTE_A; <span class="comment">// 这行比较重要，是将PTE_A那一位 置反</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">copyout</span>(pagetable, (uint64)store, (<span class="type">char</span> *)&amp;ans, <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看这个代码可能一开始会有点奇怪，因为有点看不懂返回值，看了pgtbltest.c测试文件就知道应该返回什么了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">pgaccess_test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">char</span> *buf;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> abits;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;pgaccess_test starting\n&quot;</span>);</span><br><span class="line">  testname = <span class="string">&quot;pgaccess_test&quot;</span>;</span><br><span class="line">  buf = <span class="built_in">malloc</span>(<span class="number">32</span> * PGSIZE);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">pgaccess</span>(buf, <span class="number">32</span>, &amp;abits) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">err</span>(<span class="string">&quot;pgaccess failed&quot;</span>);</span><br><span class="line">  buf[PGSIZE * <span class="number">1</span>] += <span class="number">1</span>;</span><br><span class="line">  buf[PGSIZE * <span class="number">2</span>] += <span class="number">1</span>;</span><br><span class="line">  buf[PGSIZE * <span class="number">30</span>] += <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">pgaccess</span>(buf, <span class="number">32</span>, &amp;abits) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">err</span>(<span class="string">&quot;pgaccess failed&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (abits != ((<span class="number">1</span> &lt;&lt; <span class="number">1</span>) | (<span class="number">1</span> &lt;&lt; <span class="number">2</span>) | (<span class="number">1</span> &lt;&lt; <span class="number">30</span>)))</span><br><span class="line">    <span class="built_in">err</span>(<span class="string">&quot;incorrect access bits set&quot;</span>);</span><br><span class="line">  <span class="built_in">free</span>(buf);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;pgaccess_test: OK\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可以看到先是分配了32个页，然后操作了第1个，第2个，第30个页</span></span><br><span class="line"><span class="comment">// 然后它调用pgaccess(buf, 32, &amp;abits)</span></span><br><span class="line"><span class="comment">// 这个时候它希望abits变为(1 &lt;&lt; 1) | (1 &lt;&lt; 2) | (1 &lt;&lt; 30)</span></span><br><span class="line"><span class="comment">// 也就是说哪一页被访问过，它就将abits的那一位 置为1</span></span><br><span class="line"><span class="comment">// 这样就能看懂pgaccess中的代码了。</span></span><br></pre></td></tr></table></figure>




      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/13/system-calls/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Wang Wenhui">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gray's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Gray's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/13/system-calls/" class="post-title-link" itemprop="url">system calls</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-13 14:42:50" itemprop="dateCreated datePublished" datetime="2023-04-13T14:42:50+08:00">2023-04-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-04-17 21:07:26" itemprop="dateModified" datetime="2023-04-17T21:07:26+08:00">2023-04-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/6-S081-Lab/" itemprop="url" rel="index"><span itemprop="name">6.S081 Lab</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
	<div>
		
	</div>
    <div class="post-body" itemprop="articleBody">
          <p>这个实验是让我们在xv6中增加一些新的系统调用。</p>
<h2 id="System-call-tracing"><a href="#System-call-tracing" class="headerlink" title="System call tracing"></a>System call tracing</h2><p>这个实验相对简单，实验框架中已经给出了系统调用的函数，我们需要在函数中添加想要实现的功能（当然肯定不只是这样）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面是要添加的一些东西</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//user/user.h</span></span><br><span class="line">...</span><br><span class="line"><span class="type">int</span> <span class="title function_">uptime</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">trace</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//user/usys.pl</span></span><br><span class="line">...</span><br><span class="line">entry(<span class="string">&quot;uptime&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;trace&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//kernel/syscall.h</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_close   21</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_trace   22</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//kernel/sysproc.c</span></span><br><span class="line">...</span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_trace</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// get the mask</span></span><br><span class="line">  argint(<span class="number">0</span>, &amp;(myproc()-&gt;trace_mask));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//kernel/proc.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="comment">//这里在proc结构体中添加一个新的字段trace_mask保存trace的参数</span></span><br><span class="line">  <span class="type">int</span> trace_mask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//kernel/proc.c</span></span><br><span class="line"><span class="comment">//因为trace跟踪时会exec出一个新进程执行程序，所以要将mask在fork时</span></span><br><span class="line"><span class="comment">//传递给子进程</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">    safestrcpy(np-&gt;name, p-&gt;name, <span class="keyword">sizeof</span>(p-&gt;name));</span><br><span class="line">    </span><br><span class="line">    np-&gt;trace_mask = p-&gt;trace_mask;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//kernel/syscall.c</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_trace</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">//去别的源文件里找sys_trace的定义</span></span><br><span class="line"><span class="comment">//在函数指针表里加上sys_trace</span></span><br><span class="line"><span class="type">static</span> <span class="title function_">uint64</span> <span class="params">(*syscalls[])</span><span class="params">(<span class="type">void</span>)</span> = &#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">[SYS_close]   sys_close,</span><br><span class="line">[SYS_trace]   sys_trace,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//写一个syscall名称表，快速定位</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *syscalls_name[] = &#123;</span><br><span class="line">[SYS_fork]    <span class="string">&quot;fork&quot;</span>,</span><br><span class="line">[SYS_exit]    <span class="string">&quot;exit&quot;</span>,</span><br><span class="line">[SYS_wait]    <span class="string">&quot;wait&quot;</span>,</span><br><span class="line">[SYS_pipe]    <span class="string">&quot;pipe&quot;</span>,</span><br><span class="line">[SYS_read]    <span class="string">&quot;read&quot;</span>,</span><br><span class="line">[SYS_kill]    <span class="string">&quot;kill&quot;</span>,</span><br><span class="line">[SYS_exec]    <span class="string">&quot;exec&quot;</span>,</span><br><span class="line">[SYS_fstat]   <span class="string">&quot;fstat&quot;</span>,</span><br><span class="line">[SYS_chdir]   <span class="string">&quot;chdir&quot;</span>,</span><br><span class="line">[SYS_dup]     <span class="string">&quot;dup&quot;</span>,</span><br><span class="line">[SYS_getpid]  <span class="string">&quot;getpid&quot;</span>,</span><br><span class="line">[SYS_sbrk]    <span class="string">&quot;sbrk&quot;</span>,</span><br><span class="line">[SYS_sleep]   <span class="string">&quot;sleep&quot;</span>,</span><br><span class="line">[SYS_uptime]  <span class="string">&quot;ptime&quot;</span>,</span><br><span class="line">[SYS_open]    <span class="string">&quot;open&quot;</span>,</span><br><span class="line">[SYS_write]   <span class="string">&quot;write&quot;</span>,</span><br><span class="line">[SYS_mknod]   <span class="string">&quot;mknod&quot;</span>,</span><br><span class="line">[SYS_unlink]  <span class="string">&quot;unlink&quot;</span>,</span><br><span class="line">[SYS_link]    <span class="string">&quot;link&quot;</span>,</span><br><span class="line">[SYS_mkdir]   <span class="string">&quot;mkdir&quot;</span>,</span><br><span class="line">[SYS_close]   <span class="string">&quot;close&quot;</span>,</span><br><span class="line">[SYS_trace]   <span class="string">&quot;trace&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>下面是syscall函数中内容：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">syscall</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> num;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  num = p-&gt;trapframe-&gt;a7;</span><br><span class="line">  <span class="keyword">if</span>(num &gt; <span class="number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;</span><br><span class="line">    <span class="comment">// Use num to lookup the system call function for num,</span></span><br><span class="line">    <span class="comment">// call it,</span></span><br><span class="line">    <span class="comment">// and store its return value in p-&gt;trapframe-&gt;a0</span></span><br><span class="line">    p-&gt;trapframe-&gt;a0 = syscalls[num]();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//下面是添加的部分，根据传参确认系统调用号</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="number">1</span> &lt;&lt; num) &amp; p-&gt;trace_mask) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d: syscall %s -&gt; %d\n&quot;</span>, p-&gt;pid, syscalls_name[num], p-&gt;trapframe-&gt;a0);</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %s: unknown sys call %d\n&quot;</span>,</span><br><span class="line">            p-&gt;pid, p-&gt;name, num);</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是我认为一些值得注意的地方：</p>
<ol>
<li><p><code>user/trace.c</code>中程序主要是把命令行参数中实际要执行的命令通过exec调用执行，即把trace <mask> 剥离掉</p>
</li>
<li><p><code>sys_trace()</code>中<code>argint</code>函数，原型<code>int argint(int n, int *ip)</code>，作用是将字符串格式化成整型，其中<code>*ip</code>为转换后的参数写入的地址。在<code>argint</code>内部是调用了<code>argraw(int n)</code>，<code>n</code>决定了传给<code>ip</code>的参数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">tatic uint64</span><br><span class="line"><span class="title function_">argraw</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="keyword">switch</span> (n) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">return</span> p-&gt;trapframe-&gt;a0;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">return</span> p-&gt;trapframe-&gt;a1;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    <span class="keyword">return</span> p-&gt;trapframe-&gt;a2;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    <span class="keyword">return</span> p-&gt;trapframe-&gt;a3;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">    <span class="keyword">return</span> p-&gt;trapframe-&gt;a4;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">    <span class="keyword">return</span> p-&gt;trapframe-&gt;a5;</span><br><span class="line">  &#125;</span><br><span class="line">  panic(<span class="string">&quot;argraw&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里<code>a0</code>到<code>a5</code>分别是xv6中系统调用的参数寄存器，0即为将第一个参数的值传给<code>ip</code>，这里即为输入的跟踪系统调用号。</p>
</li>
<li><p><code>fork()</code>内容修改：在<code>struct proc</code>结构体中我们增加了一个<code>int trace_mask</code>字段，在fork的时候我们要将这个字段也传给子进程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np-&gt;trace_mask = p-&gt;trace_mask;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>syscall</code>函数中，<code>p-&gt;trapframe-&gt;a7</code>即为系统调用号，<code>a7</code>寄存器存储系统调用号，前面提到<code>a0</code>到<code>a5</code>用来存系统调用的参数，<code>a6</code>寄存器用来处理需要更多参数的情况，如果系统调用需要超过6个参数，多余的参数会存入内存中，这时候<code>a6</code>寄存器就会存内存地址，以便能找到多余的参数。</p>
<p><code>a6</code>寄存器的值有可能会被其他函数调用使用，所以在用到<code>a6</code>寄存器时要将内容存在栈上，以便其他函数调用结束能恢复<code>a6</code>中的值。</p>
</li>
<li><p><code>syscall</code>中用于判断跟踪的系统调用的语句是:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span> &lt;&lt; num) &amp; p-&gt;trace_mask</span><br></pre></td></tr></table></figure>

<p>因为可能同时跟踪多个系统调用，所以用&amp;来判断，这样假如num有两位置为1，那两位系统调用都能被跟踪到。</p>
</li>
</ol>
<h2 id="Sysinfo"><a href="#Sysinfo" class="headerlink" title="Sysinfo"></a>Sysinfo</h2><p>这个实验主要是让我们熟悉xv6中与进程、内存相关代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//kernel/kalloc.c中要添加的函数 获取空闲内存数量</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">freebytes</span><span class="params">(uint64 * dst)</span></span><br><span class="line">&#123;</span><br><span class="line">  *dst = <span class="number">0</span> ;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">p</span> =</span> kmem.freelist;</span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  <span class="keyword">while</span>(p) &#123;</span><br><span class="line">    *dst += PGSIZE;</span><br><span class="line">    p = p-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//kernel/kalloc.c中要添加的函数 获取进程数</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">procnum</span><span class="params">(uint64 *dst)</span></span><br><span class="line">&#123;</span><br><span class="line">  *dst = <span class="number">0</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">  <span class="keyword">for</span> (p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;state != UNUSED)</span><br><span class="line">      (*dst)++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//kernel/sysproc中sys_sysinfo函数</span></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sysinfo</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sysinfo</span> <span class="title">info</span>;</span></span><br><span class="line">  freebytes(&amp;info.freemem);</span><br><span class="line">  procnum(&amp;info.nproc);</span><br><span class="line">  </span><br><span class="line">  uint64 dstaddr;</span><br><span class="line">  argaddr(<span class="number">0</span>,&amp;dstaddr);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (copyout(myproc()-&gt;pagetable, dstaddr, (<span class="type">char</span> *)&amp;info, <span class="keyword">sizeof</span> info) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要点：</p>
<ol>
<li><p><code>PGSIZE</code>是一个页的大小<code>riscv.h：#define PGSIZE 4096</code>，kmem是一个全局变量，只定义了一次，用来表示物理内存的分配和释放状态。</p>
</li>
<li><p><code>procnum</code>函数中的循环部分参考<code>proc.c</code>中<code>scheduler</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">      acquire(&amp;p-&gt;lock);</span><br><span class="line">      <span class="keyword">if</span>(p-&gt;state == RUNNABLE) &#123;</span><br><span class="line">        <span class="comment">// Switch to chosen process.  It is the process&#x27;s job</span></span><br><span class="line">        <span class="comment">// to release its lock and then reacquire it</span></span><br><span class="line">        <span class="comment">// b  efore jumping back to us.</span></span><br><span class="line">        p-&gt;state = RUNNING;</span><br><span class="line">        c-&gt;proc = p;</span><br><span class="line">        swtch(&amp;c-&gt;context, &amp;p-&gt;context);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Process is done running for now.</span></span><br><span class="line">        <span class="comment">// It should have changed its p-&gt;state before coming back.</span></span><br><span class="line">        c-&gt;proc = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      release(&amp;p-&gt;lock);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>NPROC</code>定义注释为<code>maximum number of processes</code>，即最大进程数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NPROC        64  <span class="comment">// maximum number of processes</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>sys_sysinfo</code>中按实验要求需要将一个<code>struct sysinfo</code>复制回用户空间，实验要求我们参阅<code>sys_fstat()</code>(kernel&#x2F;sysfile.c)和<code>filestat()</code>(kernel&#x2F;file.c)以获取如何使用<code>copyout()</code>执行此操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_fstat</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span>;</span></span><br><span class="line">  uint64 st; <span class="comment">// user pointer to struct stat</span></span><br><span class="line"></span><br><span class="line">  argaddr(<span class="number">1</span>, &amp;st);</span><br><span class="line">  <span class="keyword">if</span>(argfd(<span class="number">0</span>, <span class="number">0</span>, &amp;f) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> filestat(f, st);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">filestat</span><span class="params">(<span class="keyword">struct</span> file *f, uint64 addr)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(f-&gt;type == FD_INODE || f-&gt;type == FD_DEVICE)&#123;</span><br><span class="line">    ilock(f-&gt;ip);</span><br><span class="line">    stati(f-&gt;ip, &amp;st);</span><br><span class="line">    iunlock(f-&gt;ip);</span><br><span class="line">    <span class="keyword">if</span>(copyout(p-&gt;pagetable, addr, (<span class="type">char</span> *)&amp;st, <span class="keyword">sizeof</span>(st)) &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>argaddr()</code>会在内部调用<code>argraw()</code>，下面大概解释一下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以看出，根据传进来的n值，决定将p-&gt;trapframe中的哪个寄存器的值</span></span><br><span class="line"><span class="comment">//写入ip中，在sysinfo中即为a0</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">argaddr</span><span class="params">(<span class="type">int</span> n, uint64 *ip)</span></span><br><span class="line">&#123;</span><br><span class="line">  *ip = argraw(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> uint64</span><br><span class="line"><span class="title function_">argraw</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="keyword">switch</span> (n) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">return</span> p-&gt;trapframe-&gt;a0;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">return</span> p-&gt;trapframe-&gt;a1;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    <span class="keyword">return</span> p-&gt;trapframe-&gt;a2;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    <span class="keyword">return</span> p-&gt;trapframe-&gt;a3;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">    <span class="keyword">return</span> p-&gt;trapframe-&gt;a4;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">    <span class="keyword">return</span> p-&gt;trapframe-&gt;a5;</span><br><span class="line">  &#125;</span><br><span class="line">  panic(<span class="string">&quot;argraw&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>copyout函数原型为<code>int copyout(pagetable_t pagetable, uint64 dstva, char *src, uint64 len)</code></p>
<p>源代码中解释为</p>
<p> Copy from kernel to user.</p>
<p> Copy len bytes from src to virtual address dstva in a given page table.</p>
<p> Return 0 on success, -1 on error.</p>
<p>显而易见,sysinfo里即把info这个我们前面声明且填充了数据的变量传到我们前面从a0取出来的地址里,也就是内核返回值。</p>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/11/utilities/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Wang Wenhui">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gray's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Gray's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/11/utilities/" class="post-title-link" itemprop="url">xv6 and Unix utilities</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-11 09:16:17" itemprop="dateCreated datePublished" datetime="2023-04-11T09:16:17+08:00">2023-04-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-04-18 16:20:51" itemprop="dateModified" datetime="2023-04-18T16:20:51+08:00">2023-04-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/6-S081-Lab/" itemprop="url" rel="index"><span itemprop="name">6.S081 Lab</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
	<div>
		
	</div>
    <div class="post-body" itemprop="articleBody">
          <p>第一个实验是写一些UNIX程序，分别是sleep、pingpong、Primes、find、xargs。每个程序会让你阅读xv6中的一些源代码，学习里面一些函数的使用，然后再实现任务。</p>
<p>实验网址：[Lab: Xv6 and Unix utilities (mit.edu)](<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.S081/2022/labs/util.html">https://pdos.csail.mit.edu/6.S081/2022/labs/util.html</a></p>
<p>注：该系列实验均部分参考:</p>
<p><a target="_blank" rel="noopener" href="http://xv6.dgs.zone/labs/answers/summary.html">实验解析 · 6.S081 All-In-One (dgs.zone)</a><br><a target="_blank" rel="noopener" href="https://github.com/tommyfan34/MIT_6S081">https://github.com/tommyfan34/MIT_6S081</a></p>
<h2 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h2><p>这个实验主要是让我们学会命令行参数的使用，比较简单，没什么好说的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>,<span class="string">&quot;please enter at least one parameter&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> time = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    sleep(time);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要就是，如果没传要sleep的时间进来，就打印出一个报错信息，然后要用atoi函数将作为char*传进来的数字转换成int类型，然后main函数结束调用exit(0) （ps：实验中的要求）</p>
<h2 id="pingpong"><a href="#pingpong" class="headerlink" title="pingpong"></a>pingpong</h2><p>这个实验主要是让我们学会进程间用管道通信的方式，也比较简单，先看代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RE 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WR 1</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> parent_fd[<span class="number">2</span>];   <span class="comment">//parent_fd 是父进程向子进程传消息的管道</span></span><br><span class="line">    <span class="type">int</span> child_fd[<span class="number">2</span>];    <span class="comment">//child_fd 是子进程向父进程传消息的管道</span></span><br><span class="line">    pipe(parent_fd);</span><br><span class="line">    pipe(child_fd);</span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">64</span>];   </span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        close(parent_fd[RE]);</span><br><span class="line">        close(parent_fd[WR]);</span><br><span class="line">        close(child_fd[RE]);</span><br><span class="line">        close(child_fd[WR]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        close(child_fd[RE]);</span><br><span class="line">        close(parent_fd[WR]);</span><br><span class="line">        read(parent_fd[RE], buf, <span class="number">5</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d: received %s\n&quot;</span>,getpid(),buf);</span><br><span class="line">        write(child_fd[WR],<span class="string">&quot;pong&quot;</span>,<span class="built_in">strlen</span>(<span class="string">&quot;pong&quot;</span>));</span><br><span class="line">        close(parent_fd[RE]);</span><br><span class="line">        close(child_fd[WR]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        close(child_fd[WR]);</span><br><span class="line">        close(parent_fd[RE]);</span><br><span class="line">        write(parent_fd[WR],<span class="string">&quot;ping&quot;</span>,<span class="built_in">strlen</span>(<span class="string">&quot;ping&quot;</span>));</span><br><span class="line">        read(child_fd[RE], buf, <span class="number">5</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d: received %s\n&quot;</span>,getpid(),buf);</span><br><span class="line">        close(parent_fd[WR]);</span><br><span class="line">        close(child_fd[RE]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我认为的一些要点：</p>
<ol>
<li>pipe()函数，创建一个管道，传入数组的第一个值为管道读端，第二个值为管道写端，都是文件描述符。</li>
<li>fork()函数，创建一个子进程，父进程和子进程都会返回，父进程返回自己的进程号（大于0），子进程返回0，并且父子进程都从当前位置开始执行。</li>
<li>及时关闭用不到的文件描述符，比如在此例中，父进程通过parent_fd传消息给子进程，子进程通过child_fd传消息给父进程，这意味着父进程中，parent_fd的读端和child_fd的写端是不需要的，可以close()。子进程同理。</li>
<li>不关闭文件描述符的危害：在这个程序中没有问题，但如果在多次read的程序中，假如在子进程中parent_fd的写端没有关闭，第一次read操作读到了管道中的父进程传递的数据，执行到第二次read，假如此时父进程的parent_fd的写端已经被关闭且管道中没有数据，由于子进程中没关闭，所以read操作会一直阻塞，直到有数据传入到管道中，可这时子进程阻塞了，没法跳出，这就是没有及时关闭不需要的文件描述符的后果。</li>
</ol>
<h2 id="primes"><a href="#primes" class="headerlink" title="primes"></a>primes</h2><p>这个实验主要是让我们通过管道的方式来进行素数筛选，加强我们对父子进程和管道的理解。有几个要求：</p>
<ol>
<li>用pipe和fork设置管道，第一个进程将2~35写管道。</li>
<li>对每个素数，创建一个进程，该进程从左边管道读取数据，向右边管道写入数据。</li>
<li>打印出每个素数。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pri</span><span class="params">(<span class="type">int</span> * parent_fd)</span> ;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> parent_fd[<span class="number">2</span>];</span><br><span class="line">    pipe(parent_fd);</span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>,<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        pri(parent_fd);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        close(parent_fd[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">35</span>; i++) &#123;</span><br><span class="line">            write(parent_fd[<span class="number">1</span>],&amp;i,<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        close(parent_fd[<span class="number">1</span>]);</span><br><span class="line">        wait(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pri</span><span class="params">(<span class="type">int</span> * parent_fd)</span> &#123;</span><br><span class="line">    close(parent_fd[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> child_fd[<span class="number">2</span>];</span><br><span class="line">    pipe(child_fd);</span><br><span class="line">    <span class="comment">//int* buf[35];</span></span><br><span class="line">    <span class="type">int</span> buf;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result = read(parent_fd[<span class="number">0</span>],&amp;buf,<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>,<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        pri(child_fd);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        close(child_fd[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;prime %d\n&quot;</span>,buf);</span><br><span class="line">        <span class="type">int</span> prime = buf;</span><br><span class="line">        <span class="keyword">while</span> (read(parent_fd[<span class="number">0</span>], &amp;buf, <span class="keyword">sizeof</span>(<span class="type">int</span>))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (buf % prime != <span class="number">0</span> ) &#123;</span><br><span class="line">                write(child_fd[<span class="number">1</span>], &amp;buf, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        close(child_fd[<span class="number">1</span>]);</span><br><span class="line">        wait(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个实验有点难度，思路大概是这样，定义一个函数在子进程递归处理数据</p>
<p>pri的作用大概是这样：</p>
<p>对于传进来的父进程的管道描述符，读取第一个数据，如果读到的字节数为0，说明数据已经处理完了，就可以exit了。</p>
<p>如果没读完，继续fork子进程^2，子进程^2中继续调用pri，这里pri传进去的是该子进程新创建的管道，这个管道中的数据将是处理过的数据。(注：这里子进程^2代表子进程又fork的子进程)</p>
<p>子进程将第一个数据打印出来，这里的原因是，已知第一个数2为素数，所以第一个子进程打印出来的一定是2，这个子进程会做一个处理，将35内所有2的倍数从传给子进程^2的管道中剔除。所以管道中的第一个数永远都是素数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      <span class="comment">//buf为此前管道中读取到的第一个值</span></span><br><span class="line"><span class="type">int</span> prime = buf;</span><br><span class="line"><span class="keyword">while</span> (read(parent_fd[RE], &amp;buf, <span class="keyword">sizeof</span>(<span class="type">int</span>))) &#123;</span><br><span class="line">          <span class="keyword">if</span> (buf % prime != <span class="number">0</span> ) &#123;</span><br><span class="line">              write(child_fd[WR], &amp;buf, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p>当然，及时关闭不需要的文件描述符是不必多说的了。</p>
<h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><p>这个实验主要是让我们写一个简单版的UNIXfind程序，查找文件目录中具有特定名称的所有文件。实验让我们先阅读xv6中ls的代码学习怎么读取目录，要求find使用递归不断进入子目录中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里先给出两个结构体的定义</span></span><br><span class="line"><span class="comment">//struct dirent结构体描述了一个文件的inum标识和名字。</span></span><br><span class="line"><span class="comment">//文件（可能是file、directory、device）</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span>结构体描述了一个文件的具体信息，包括文件类型、大小、<span class="title">inode</span> <span class="title">number</span>、引用计数等。</span></span><br><span class="line"><span class="class">#<span class="title">define</span> <span class="title">DIRSIZ</span> 14</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> &#123;</span></span><br><span class="line">  ushort inum;</span><br><span class="line">  <span class="type">char</span> name[DIRSIZ];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_DIR     1   <span class="comment">// Directory</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_FILE    2   <span class="comment">// File</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_DEVICE  3   <span class="comment">// Device</span></span></span><br><span class="line"><span class="comment">//这里是三个宏定义给出的是stat中type类型</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> dev;     <span class="comment">// File system&#x27;s disk device</span></span><br><span class="line">  uint ino;    <span class="comment">// Inode number</span></span><br><span class="line">  <span class="type">short</span> type;  <span class="comment">// Type of file</span></span><br><span class="line">  <span class="type">short</span> nlink; <span class="comment">// Number of links to file</span></span><br><span class="line">  uint64 size; <span class="comment">// Size of file in bytes</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/fs.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">find</span><span class="params">(<span class="type">char</span> * path, <span class="type">char</span> * file)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>,<span class="string">&quot;need more params&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> * path = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="type">char</span> * file = argv[<span class="number">2</span>];</span><br><span class="line">    find(path, file);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">find</span> <span class="params">(<span class="type">char</span> * path, <span class="type">char</span> * file)</span> &#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">512</span>], *p;</span><br><span class="line">  	<span class="type">int</span> fd;</span><br><span class="line">  	<span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> <span class="title">de</span>;</span></span><br><span class="line">  	<span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((fd = open(path,<span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>,<span class="string">&quot;ERROR: cannot open %s\n&quot;</span>, path);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fstat(fd, &amp;st) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>,<span class="string">&quot;ERROR: cannot stat %s\n&quot;</span>, path);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里没有像ls一样先判断类型是因为传进来的path一定是路径，</span></span><br><span class="line">    <span class="comment">//不会是文件</span></span><br><span class="line">    <span class="keyword">while</span> (read(fd, &amp;de, <span class="keyword">sizeof</span>(de)) == <span class="keyword">sizeof</span>(de)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (de.inum == <span class="number">0</span>)  <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">strcpy</span>(buf,path);</span><br><span class="line">        p = buf + <span class="built_in">strlen</span>(buf);</span><br><span class="line">        *p++ = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">        memmove(p, de.name, DIRSIZ);</span><br><span class="line">        p[DIRSIZ] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (stat(buf, &amp;st) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;ERROR: cannot stat %s\n&quot;</span>, buf);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span>(st.type) &#123;</span><br><span class="line">            <span class="keyword">case</span> T_DEVICE:</span><br><span class="line">            <span class="keyword">case</span> T_FILE:</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">strcmp</span>(file, de.name) == <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buf);</span><br><span class="line">			&#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> T_DIR:</span><br><span class="line">                <span class="keyword">if</span> ((<span class="built_in">strcmp</span>(de.name, <span class="string">&quot;.&quot;</span>) != <span class="number">0</span>) &amp;&amp; (<span class="built_in">strcmp</span>(de.name, <span class="string">&quot;..&quot;</span>) != <span class="number">0</span>)) &#123;</span><br><span class="line">				    find(buf, file);</span><br><span class="line">                &#125;               </span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里只要仔细看一下xv6中的ls代码，了解struct dirent、struct stat结构体、open、fstat、stat函数的作用就能写出来。</p>
<p>在该程序中，open函数返回path的文件描述符，fstat会将该path的信息传进定义的struct stat类型st中，和ls中不同的是，这里不会先判断类型，因为path一定是传进来的路径而不是文件（不考虑报错的情况下），while循环中每次读取该path下的一个文件（可能是file、directory、device），然后用stat函数将该文件的信息传入st中，接着判断类型，如果是文件就查看是否匹配输入的文件名，如果是目录就递归调用find函数。</p>
<p>注：这里fstat和stat不同的地方在于，传入fstat的是文件描述符和stat，而传入stat的是char*和stat。fstat是一个system call，而stat只是一个普通的函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fstat</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> stat*)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">stat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *n, <span class="keyword">struct</span> stat *st)</span>;</span><br></pre></td></tr></table></figure>

<h2 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h2><p>这个实验我觉得要求给的有点绕，可能是之前不清楚xargs的作用吧，参考了一下别人的代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/param.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/fs.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLEN 20</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> * argv[])</span> &#123;</span><br><span class="line">    <span class="type">char</span>* command = argv[<span class="number">1</span>]; <span class="comment">//grep</span></span><br><span class="line">    <span class="type">char</span> params[MAXARG][MAXLEN];</span><br><span class="line">    <span class="type">char</span> buf;</span><br><span class="line">    <span class="type">char</span>* m[MAXARG];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//外层循环每次执行一个指令</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> count = argc - <span class="number">1</span>;<span class="comment">//</span></span><br><span class="line">        <span class="built_in">memset</span>(params,<span class="number">0</span>,MAXARG * MAXLEN);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; argc; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">strcpy</span>(params[i<span class="number">-1</span>], argv[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> cursor = <span class="number">0</span>; <span class="comment">// 字符串中的位置</span></span><br><span class="line">		<span class="type">int</span> flag = <span class="number">0</span>; <span class="comment">// 空格前是否有参数</span></span><br><span class="line">		<span class="type">int</span> read_result;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//内层循环每次读取一行指令m数组中</span></span><br><span class="line">        <span class="comment">//文件描述符0 是命令行读取</span></span><br><span class="line">        <span class="keyword">while</span> (((read_result = read(<span class="number">0</span>, &amp;buf, <span class="number">1</span>))) &gt; <span class="number">0</span> &amp;&amp; buf != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (buf == <span class="string">&#x27; &#x27;</span> &amp;&amp; flag == <span class="number">1</span>) &#123;</span><br><span class="line">				count++;</span><br><span class="line">				<span class="comment">// reset flag and p</span></span><br><span class="line">				cursor = <span class="number">0</span>;</span><br><span class="line">				flag = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (buf != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">				params[count][cursor++] = buf;</span><br><span class="line">				flag = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// encounters EOF of input or \n</span></span><br><span class="line">		<span class="keyword">if</span> (read_result &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;MAXARG<span class="number">-1</span>; i++) &#123;</span><br><span class="line">			m[i] = params[i];</span><br><span class="line">		&#125;</span><br><span class="line">		m[MAXARG<span class="number">-1</span>] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;</span><br><span class="line">			exec(command, m);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			wait((<span class="type">int</span> *) <span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的关键是，传给xargs中argv[1]是实际要执行的命令，接着程序会循环执行每一条命令行中输入的命令。先把命令行参数依次复制到params数组中，然后再读取标准输入的内容，写入params接下来的位置中（上一步中，params写到params[argc-2],这步从argc-1开始写），读取到换行符或EOF后就fork出子进程执行命令。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/27/Makefile/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Wang Wenhui">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gray's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Gray's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/03/27/Makefile/" class="post-title-link" itemprop="url">Makefile</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-03-27 08:43:54 / 修改时间：17:29:48" itemprop="dateCreated datePublished" datetime="2023-03-27T08:43:54+08:00">2023-03-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CPP/" itemprop="url" rel="index"><span itemprop="name">CPP</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
	<div>
		
	</div>
    <div class="post-body" itemprop="articleBody">
          <h1 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h1><h2 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h2><p>一个Makefile文件由一个<strong>规则</strong>或多个<strong>规则</strong>组成<br>其他规则一般为第一条规则服务</p>
<p><strong>目标 …: 依赖 …<br>    命令（shell命令）<br>    …</strong></p>
<p>目标：最终要生成的文件<br>依赖：生成目标需要的文件或是目标<br>命令：执行命令对依赖操作，生成目标（必须tab缩进）</p>
<p>示例：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">mubiao: yilai1.c yilai2.c yilai3.c</span></span><br><span class="line">	gcc yilai1.c yilai2.c yilai3.c -o mubiao</span><br></pre></td></tr></table></figure>

<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><h6 id="命令在执行之前，需要先检查规则中的依赖是否存在"><a href="#命令在执行之前，需要先检查规则中的依赖是否存在" class="headerlink" title="命令在执行之前，需要先检查规则中的依赖是否存在"></a>命令在执行之前，需要先检查规则中的依赖是否存在</h6><ol>
<li>存在，执行命令</li>
<li>不存在，向下检查其他的规则，查看是否有一个规则是生成这个依赖的，找到就执行这个生成依赖的规则，再执行当前命令</li>
</ol>
<h6 id="检测更新，在执行规则中的命令时，会比较目标和依赖文件的时间"><a href="#检测更新，在执行规则中的命令时，会比较目标和依赖文件的时间" class="headerlink" title="检测更新，在执行规则中的命令时，会比较目标和依赖文件的时间"></a>检测更新，在执行规则中的命令时，会比较目标和依赖文件的时间</h6><ol>
<li>如果依赖的时间比目标的时间晚，需要重新生成目标</li>
<li>如果依赖的时间比目标的时间早，目标不需要更新，对应规则的命令不需要被执行</li>
</ol>
<h6 id="如果有其他规则不会影响到第一条规则的执行，则不会执行"><a href="#如果有其他规则不会影响到第一条规则的执行，则不会执行" class="headerlink" title="如果有其他规则不会影响到第一条规则的执行，则不会执行"></a>如果有其他规则不会影响到第一条规则的执行，则不会执行</h6><p>问题：如果我第一条规则中的依赖需要第二条规则执行，而第二条规则的依赖又需要第三条规则执行，这样可行吗？</p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>自定义变量：<br>    变量名&#x3D;变量值	var&#x3D;hello		$(var)<br>预定义变量：(这部分只能在<strong>命令</strong>中使用)<br>    AR：归档维护程序的名称，默认为ar<br>    CC：C编译器的名称，默认为cc<br>    CXX：C++编译器的名称，默认为g++<br>    $@:	目标的完整名称<br>    $&lt;：第一个依赖文件的名称<br>    $^：所有的依赖文件<br>获取变量的值<br>    $(变量名)</p>
<p>示例：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">app:main.c a.c b.c</span></span><br><span class="line">	gcc -c main.c a.c b.c</span><br><span class="line">	</span><br><span class="line"><span class="section">app:main.c a.c b.c</span></span><br><span class="line">	<span class="variable">$(CC)</span> -c <span class="variable">$^</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure>

<h2 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h2><p>%.o:%.c<br>    %：通配符，匹配一个字符串	两个%匹配的是一个字符串</p>
<p>示例：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">%.o:%.c</span></span><br><span class="line">	gcc -c &amp;&lt; -o &amp;@</span><br></pre></td></tr></table></figure>

<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>$(funcname params)</p>
<p>示例：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">wildcard</span> PATTERN...)</span></span><br><span class="line"><span class="comment">#功能：获取指定目录下指定类型的文件列表</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#参数：PATTERN指的是某个或多个目录下的对应的某种类型的文件，如果有多个目录，一般用空格间隔</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#返回：得到的若干个文件的列表，用空格隔开</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(<span class="built_in">wildcard</span> *.c ./sub/*.c)</span></span><br><span class="line"><span class="comment">#返回格式：a.c b.c c.c d.c e.c f.c</span></span><br></pre></td></tr></table></figure>

<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">patsubst</span> &lt;pattern&gt;,&lt;replacement&gt;,&lt;text&gt;)</span></span><br><span class="line"><span class="comment">#功能：查找&lt;text&gt;中的单词是否符合模式&lt;pattern&gt;，符合就用&lt;replacement&gt;替换</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#&lt;pattern&gt;可以包括通配符&#x27;%&#x27;，表示任意长度的字符串，如果&lt;replacement&gt;中也包含&#x27;%&#x27;,则这个字符串将是前面代表的字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#返回：函数返回被替换过后的字符串</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(<span class="built_in">patsubst</span> %.c, %.o, x.c bar.c)</span></span><br><span class="line"><span class="comment">#返回格式：x.o bar.o</span></span><br></pre></td></tr></table></figure>

<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>可以手动创建命令:</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="keyword">.PHONY</span>:clean</span></span><br><span class="line"><span class="section">make:</span></span><br><span class="line">	rm xxx -f</span><br><span class="line"><span class="comment">#.PHONY表示clean是伪目标，不会生成文件</span></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/23/%E9%9D%99%E6%80%81%E5%BA%93%E5%92%8C%E5%8A%A8%E6%80%81%E5%BA%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Wang Wenhui">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gray's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Gray's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/03/23/%E9%9D%99%E6%80%81%E5%BA%93%E5%92%8C%E5%8A%A8%E6%80%81%E5%BA%93/" class="post-title-link" itemprop="url">静态库和动态库</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-03-23 16:30:10" itemprop="dateCreated datePublished" datetime="2023-03-23T16:30:10+08:00">2023-03-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-03-27 08:34:19" itemprop="dateModified" datetime="2023-03-27T08:34:19+08:00">2023-03-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CPP/" itemprop="url" rel="index"><span itemprop="name">CPP</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
	<div>
		
	</div>
    <div class="post-body" itemprop="articleBody">
          <h1 id="库"><a href="#库" class="headerlink" title="库"></a>库</h1><p> 两种库：静态库和动态库 （共享库）</p>
<p><strong>区别：</strong> 静态库在程序的链接阶段被复制到了程序中；动态库在链接阶段没有被复制到程序中，而是程序在运行时由系统动态加载到内存中供程序调用。</p>
<p><strong>好处：</strong>1、代码保密。2、方便部署和开发</p>
<h2 id="静态库"><a href="#静态库" class="headerlink" title="静态库"></a>静态库</h2><p><em><strong>命名规则：</strong></em></p>
<p>​	Linux：libxxx.a<br>​		lib：前缀（固定）<br>​		xxx：库的名字，自己起<br>​		.a：后缀（固定）</p>
<p>​	Windows：libxxx.lib</p>
<p><em><strong>制作：</strong></em></p>
<p>​	gcc获得.o文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c xxx.c xxx.c xxx.c</span><br></pre></td></tr></table></figure>

<p>​	将.o文件打包，使用ac工具（archive）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ar rcs libxxx.a xxx.o xxx.o</span><br></pre></td></tr></table></figure>

<p>​	r - 将文件插入备存文件中</p>
<p>​	c - 建立备存文件</p>
<p>​	s - 索引</p>
<p><em><strong>使用：</strong></em></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c -o xxx -I 头文件所在文件夹 -l 名字 库所在文件夹 </span><br></pre></td></tr></table></figure>

<h2 id="动态库"><a href="#动态库" class="headerlink" title="动态库"></a>动态库</h2><p><em><strong>命名规则：</strong></em></p>
<p>​	Linux：libxxx.so<br>​		lib：前缀（固定）<br>​		xxx：库的名字，自己起<br>​		.so：后缀（固定）<br>​		在Linux下是一个可执行文件</p>
<p>​	Windows：libxxx.dll</p>
<p><em><strong>制作：</strong></em></p>
<p>​	gcc获得.o文件，<strong>得到和位置无关的代码</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c -fpic/-fPIC xxx.c xxx.c</span><br></pre></td></tr></table></figure>

<p>​	gcc得到动态库</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -shared xxx.o xxx.o -o libxxx.so</span><br></pre></td></tr></table></figure>

<p><em><strong>使用：</strong></em></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c -o xxx -I 头文件所在文件夹 -L 库所在文件夹 -l 名字</span><br></pre></td></tr></table></figure>

<p> 发现运行不了，因为系统要知道绝对路径</p>
<p>第一种方法：修改环境变量LD_LIBRARY_PATH</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:要添加的文件夹目录</span><br></pre></td></tr></table></figure>

<p>永久配置：</p>
<p>用户配置：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vim .bashrc</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">进入了.bashrc 用vim编辑 在末尾增加</span></span><br><span class="line">export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:要添加的路径</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">保存 然后<span class="built_in">source</span></span></span><br><span class="line"></span><br><span class="line">source .bashrc</span><br></pre></td></tr></table></figure>

<p>系统配置：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/profile</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">在末尾增加</span></span><br><span class="line">export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:要添加的路径</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">保存 然后<span class="built_in">source</span></span></span><br><span class="line"></span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure>

<p>第二种方法：修改&#x2F;etc&#x2F;ld.so.cache文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/ld.so.conf</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">把路径写在里面就行，然后保存退出，更新</span></span><br><span class="line"></span><br><span class="line">sudo ldconfig</span><br></pre></td></tr></table></figure>

<p>第三种方法：把库文件放在&#x2F;lib&#x2F;或&#x2F;usr&#x2F;lib目录下（不推荐）</p>
<h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p><strong>静态库：</strong><br>    优点：<br>        · 被打包到应用程序中加载速度快<br>        · 发布程序不用提供静态库，移植方便</p>
<p>​	缺点：<br>​		· 消耗系统资源，浪费内存<br>​		· 更新、部署、发布麻烦</p>
<p><strong>动态库：</strong><br>    优点：<br>        · 可以实现进程间资源共享<br>        · 更新、部署、发布简单<br>        · 可以控制何时加载动态库</p>
<p>​	缺点：<br>​		· 加载速度比静态库慢<br>​		· 发布程序时需要提供依赖的动态库</p>
<p>之前写过一次贪吃蛇，打包给同学试试的时候，用静态库所有同学都能玩，而用动态库有些同学就玩不了了，就是这个道理。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/11/CPP%E5%A4%A7%E5%B0%8F%E6%A0%B9%E5%A0%86-priority-queue/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Wang Wenhui">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gray's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Gray's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/03/11/CPP%E5%A4%A7%E5%B0%8F%E6%A0%B9%E5%A0%86-priority-queue/" class="post-title-link" itemprop="url">CPP大小根堆-priority_queue</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-03-11 14:44:25 / 修改时间：16:42:56" itemprop="dateCreated datePublished" datetime="2023-03-11T14:44:25+08:00">2023-03-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
	<div>
		
	</div>
    <div class="post-body" itemprop="articleBody">
          <h1 id="概述和模板定义"><a href="#概述和模板定义" class="headerlink" title="概述和模板定义"></a>概述和模板定义</h1><p>priority_queue容器在头文件<queue>中，位于std命名空间中,容器是有序的。</p>
<p>模板定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;	<span class="keyword">typename</span> T,							<span class="comment">//容器中元素的类型</span></span><br><span class="line">        	<span class="keyword">typename</span> Container=std::vector&lt;T&gt;,	<span class="comment">//底层使用的容器，vector或</span></span><br><span class="line">												<span class="comment">//deque</span></span><br><span class="line">        	<span class="keyword">typename</span> Compare=std::less&lt;T&gt; &gt;	<span class="comment">//排序规则</span></span><br><span class="line">                							<span class="comment">//std::less&lt;T&gt; 		从大到小</span></span><br><span class="line">                							<span class="comment">//std::greater&lt;T&gt;	从小到大</span></span><br><span class="line">                							<span class="comment">//还可以自定义规则，做题一般不用</span></span><br><span class="line"><span class="keyword">class</span> priority_queue&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="创建容器的方法"><a href="#创建容器的方法" class="headerlink" title="创建容器的方法"></a>创建容器的方法</h1><p>最基本的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::priority_queue&lt;<span class="type">int</span>&gt; values;</span><br></pre></td></tr></table></figure>

<p>使用普通数组或其他容器：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用普通数组</span></span><br><span class="line"><span class="type">int</span> values[]&#123;<span class="number">4</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="function">std::priority_queue&lt;<span class="type">int</span>&gt; <span class="title">copy_values</span><span class="params">(values,values+<span class="number">4</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用序列式容器</span></span><br><span class="line">std::array&lt;<span class="type">int</span>,4&gt;values&#123; <span class="number">4</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span> &#125;;</span><br><span class="line"><span class="function">std::priority_queue&lt;<span class="type">int</span>&gt; <span class="title">copy_values</span><span class="params">(values.begin(),values.end())</span></span>;</span><br></pre></td></tr></table></figure>

<p>手动指定：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> values[]&#123; <span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;;</span><br><span class="line">std::priority_queue&lt;<span class="type">int</span>, std::deque&lt;<span class="type">int</span>&gt;, std::greater&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">copy_values</span>(values, values+<span class="number">4</span>);</span><br></pre></td></tr></table></figure>

<h1 id="常用成员函数"><a href="#常用成员函数" class="headerlink" title="常用成员函数"></a>常用成员函数</h1><table>
<thead>
<tr>
<th>成员函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>empty()</td>
<td>如果 priority_queue 为空的话，返回 true；反之，返回 false。</td>
</tr>
<tr>
<td>size()</td>
<td>返回 priority_queue 中存储元素的个数。</td>
</tr>
<tr>
<td>top()</td>
<td>返回 priority_queue 中第一个元素的引用形式。</td>
</tr>
<tr>
<td>push(const T&amp; obj)</td>
<td>根据既定的排序规则，将元素 obj 的副本存储到 priority_queue 中适当的位置。</td>
</tr>
<tr>
<td>push(T&amp;&amp; obj)</td>
<td>根据既定的排序规则，将元素 obj 移动存储到 priority_queue 中适当的位置。</td>
</tr>
<tr>
<td>emplace(Args&amp;&amp;… args)</td>
<td>Args&amp;&amp;… args 表示构造一个存储类型的元素所需要的数据（对于类对象来说，可能需要多个数据构造出一个对象）。此函数的功能是根据既定的排序规则，在容器适配器适当的位置直接生成该新元素。</td>
</tr>
<tr>
<td>pop()</td>
<td>移除 priority_queue 容器适配器中第一个元素。</td>
</tr>
<tr>
<td>swap(priority_queue<T>&amp; other)</td>
<td>将两个 priority_queue 容器适配器中的元素进行互换，需要注意的是，进行互换的 2 个 priority_queue 容器适配器中存储的元素类型以及底层采用的基础容器类型，都必须相同。</td>
</tr>
</tbody></table>
<p>适用于题目：（待补充）</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/6987.html">http://c.biancheng.net/view/6987.html</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Wang Wenhui</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  





  





<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
