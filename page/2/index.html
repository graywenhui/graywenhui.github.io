<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/all.min.css" integrity="sha256-AbA177XfpSnFEvgpYu1jMygiLabzPCJCRIBtR5jGc0k=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.13.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":{"enable":true,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="Gray&#39;s Blog">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="Gray&#39;s Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Wang Wenhui">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/2/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/2/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Gray's Blog</title>
  






  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>


<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Gray's Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Wang Wenhui</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">47</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/11/utilities/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Wang Wenhui">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gray's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Gray's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/11/utilities/" class="post-title-link" itemprop="url">xv6 and Unix utilities</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-11 09:16:17" itemprop="dateCreated datePublished" datetime="2023-04-11T09:16:17+08:00">2023-04-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-04-18 16:20:51" itemprop="dateModified" datetime="2023-04-18T16:20:51+08:00">2023-04-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/6-S081-Lab/" itemprop="url" rel="index"><span itemprop="name">6.S081 Lab</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
	<div>
		
	</div>
    <div class="post-body" itemprop="articleBody">
          <p>第一个实验是写一些UNIX程序，分别是sleep、pingpong、Primes、find、xargs。每个程序会让你阅读xv6中的一些源代码，学习里面一些函数的使用，然后再实现任务。</p>
<p>实验网址：[Lab: Xv6 and Unix utilities (mit.edu)](<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.S081/2022/labs/util.html">https://pdos.csail.mit.edu/6.S081/2022/labs/util.html</a></p>
<p>注：该系列实验均部分参考:</p>
<p><a target="_blank" rel="noopener" href="http://xv6.dgs.zone/labs/answers/summary.html">实验解析 · 6.S081 All-In-One (dgs.zone)</a><br><a target="_blank" rel="noopener" href="https://github.com/tommyfan34/MIT_6S081">https://github.com/tommyfan34/MIT_6S081</a></p>
<h2 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h2><p>这个实验主要是让我们学会命令行参数的使用，比较简单，没什么好说的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>,<span class="string">&quot;please enter at least one parameter&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> time = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    sleep(time);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要就是，如果没传要sleep的时间进来，就打印出一个报错信息，然后要用atoi函数将作为char*传进来的数字转换成int类型，然后main函数结束调用exit(0) （ps：实验中的要求）</p>
<h2 id="pingpong"><a href="#pingpong" class="headerlink" title="pingpong"></a>pingpong</h2><p>这个实验主要是让我们学会进程间用管道通信的方式，也比较简单，先看代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RE 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WR 1</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> parent_fd[<span class="number">2</span>];   <span class="comment">//parent_fd 是父进程向子进程传消息的管道</span></span><br><span class="line">    <span class="type">int</span> child_fd[<span class="number">2</span>];    <span class="comment">//child_fd 是子进程向父进程传消息的管道</span></span><br><span class="line">    pipe(parent_fd);</span><br><span class="line">    pipe(child_fd);</span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">64</span>];   </span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        close(parent_fd[RE]);</span><br><span class="line">        close(parent_fd[WR]);</span><br><span class="line">        close(child_fd[RE]);</span><br><span class="line">        close(child_fd[WR]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        close(child_fd[RE]);</span><br><span class="line">        close(parent_fd[WR]);</span><br><span class="line">        read(parent_fd[RE], buf, <span class="number">5</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d: received %s\n&quot;</span>,getpid(),buf);</span><br><span class="line">        write(child_fd[WR],<span class="string">&quot;pong&quot;</span>,<span class="built_in">strlen</span>(<span class="string">&quot;pong&quot;</span>));</span><br><span class="line">        close(parent_fd[RE]);</span><br><span class="line">        close(child_fd[WR]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        close(child_fd[WR]);</span><br><span class="line">        close(parent_fd[RE]);</span><br><span class="line">        write(parent_fd[WR],<span class="string">&quot;ping&quot;</span>,<span class="built_in">strlen</span>(<span class="string">&quot;ping&quot;</span>));</span><br><span class="line">        read(child_fd[RE], buf, <span class="number">5</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d: received %s\n&quot;</span>,getpid(),buf);</span><br><span class="line">        close(parent_fd[WR]);</span><br><span class="line">        close(child_fd[RE]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我认为的一些要点：</p>
<ol>
<li>pipe()函数，创建一个管道，传入数组的第一个值为管道读端，第二个值为管道写端，都是文件描述符。</li>
<li>fork()函数，创建一个子进程，父进程和子进程都会返回，父进程返回自己的进程号（大于0），子进程返回0，并且父子进程都从当前位置开始执行。</li>
<li>及时关闭用不到的文件描述符，比如在此例中，父进程通过parent_fd传消息给子进程，子进程通过child_fd传消息给父进程，这意味着父进程中，parent_fd的读端和child_fd的写端是不需要的，可以close()。子进程同理。</li>
<li>不关闭文件描述符的危害：在这个程序中没有问题，但如果在多次read的程序中，假如在子进程中parent_fd的写端没有关闭，第一次read操作读到了管道中的父进程传递的数据，执行到第二次read，假如此时父进程的parent_fd的写端已经被关闭且管道中没有数据，由于子进程中没关闭，所以read操作会一直阻塞，直到有数据传入到管道中，可这时子进程阻塞了，没法跳出，这就是没有及时关闭不需要的文件描述符的后果。</li>
</ol>
<h2 id="primes"><a href="#primes" class="headerlink" title="primes"></a>primes</h2><p>这个实验主要是让我们通过管道的方式来进行素数筛选，加强我们对父子进程和管道的理解。有几个要求：</p>
<ol>
<li>用pipe和fork设置管道，第一个进程将2~35写管道。</li>
<li>对每个素数，创建一个进程，该进程从左边管道读取数据，向右边管道写入数据。</li>
<li>打印出每个素数。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pri</span><span class="params">(<span class="type">int</span> * parent_fd)</span> ;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> parent_fd[<span class="number">2</span>];</span><br><span class="line">    pipe(parent_fd);</span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>,<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        pri(parent_fd);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        close(parent_fd[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">35</span>; i++) &#123;</span><br><span class="line">            write(parent_fd[<span class="number">1</span>],&amp;i,<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        close(parent_fd[<span class="number">1</span>]);</span><br><span class="line">        wait(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pri</span><span class="params">(<span class="type">int</span> * parent_fd)</span> &#123;</span><br><span class="line">    close(parent_fd[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> child_fd[<span class="number">2</span>];</span><br><span class="line">    pipe(child_fd);</span><br><span class="line">    <span class="comment">//int* buf[35];</span></span><br><span class="line">    <span class="type">int</span> buf;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result = read(parent_fd[<span class="number">0</span>],&amp;buf,<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>,<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        pri(child_fd);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        close(child_fd[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;prime %d\n&quot;</span>,buf);</span><br><span class="line">        <span class="type">int</span> prime = buf;</span><br><span class="line">        <span class="keyword">while</span> (read(parent_fd[<span class="number">0</span>], &amp;buf, <span class="keyword">sizeof</span>(<span class="type">int</span>))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (buf % prime != <span class="number">0</span> ) &#123;</span><br><span class="line">                write(child_fd[<span class="number">1</span>], &amp;buf, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        close(child_fd[<span class="number">1</span>]);</span><br><span class="line">        wait(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个实验有点难度，思路大概是这样，定义一个函数在子进程递归处理数据</p>
<p>pri的作用大概是这样：</p>
<p>对于传进来的父进程的管道描述符，读取第一个数据，如果读到的字节数为0，说明数据已经处理完了，就可以exit了。</p>
<p>如果没读完，继续fork子进程^2，子进程^2中继续调用pri，这里pri传进去的是该子进程新创建的管道，这个管道中的数据将是处理过的数据。(注：这里子进程^2代表子进程又fork的子进程)</p>
<p>子进程将第一个数据打印出来，这里的原因是，已知第一个数2为素数，所以第一个子进程打印出来的一定是2，这个子进程会做一个处理，将35内所有2的倍数从传给子进程^2的管道中剔除。所以管道中的第一个数永远都是素数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      <span class="comment">//buf为此前管道中读取到的第一个值</span></span><br><span class="line"><span class="type">int</span> prime = buf;</span><br><span class="line"><span class="keyword">while</span> (read(parent_fd[RE], &amp;buf, <span class="keyword">sizeof</span>(<span class="type">int</span>))) &#123;</span><br><span class="line">          <span class="keyword">if</span> (buf % prime != <span class="number">0</span> ) &#123;</span><br><span class="line">              write(child_fd[WR], &amp;buf, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p>当然，及时关闭不需要的文件描述符是不必多说的了。</p>
<h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><p>这个实验主要是让我们写一个简单版的UNIXfind程序，查找文件目录中具有特定名称的所有文件。实验让我们先阅读xv6中ls的代码学习怎么读取目录，要求find使用递归不断进入子目录中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里先给出两个结构体的定义</span></span><br><span class="line"><span class="comment">//struct dirent结构体描述了一个文件的inum标识和名字。</span></span><br><span class="line"><span class="comment">//文件（可能是file、directory、device）</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span>结构体描述了一个文件的具体信息，包括文件类型、大小、<span class="title">inode</span> <span class="title">number</span>、引用计数等。</span></span><br><span class="line"><span class="class">#<span class="title">define</span> <span class="title">DIRSIZ</span> 14</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> &#123;</span></span><br><span class="line">  ushort inum;</span><br><span class="line">  <span class="type">char</span> name[DIRSIZ];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_DIR     1   <span class="comment">// Directory</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_FILE    2   <span class="comment">// File</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_DEVICE  3   <span class="comment">// Device</span></span></span><br><span class="line"><span class="comment">//这里是三个宏定义给出的是stat中type类型</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> dev;     <span class="comment">// File system&#x27;s disk device</span></span><br><span class="line">  uint ino;    <span class="comment">// Inode number</span></span><br><span class="line">  <span class="type">short</span> type;  <span class="comment">// Type of file</span></span><br><span class="line">  <span class="type">short</span> nlink; <span class="comment">// Number of links to file</span></span><br><span class="line">  uint64 size; <span class="comment">// Size of file in bytes</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/fs.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">find</span><span class="params">(<span class="type">char</span> * path, <span class="type">char</span> * file)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>,<span class="string">&quot;need more params&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> * path = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="type">char</span> * file = argv[<span class="number">2</span>];</span><br><span class="line">    find(path, file);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">find</span> <span class="params">(<span class="type">char</span> * path, <span class="type">char</span> * file)</span> &#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">512</span>], *p;</span><br><span class="line">  	<span class="type">int</span> fd;</span><br><span class="line">  	<span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> <span class="title">de</span>;</span></span><br><span class="line">  	<span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((fd = open(path,<span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>,<span class="string">&quot;ERROR: cannot open %s\n&quot;</span>, path);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fstat(fd, &amp;st) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>,<span class="string">&quot;ERROR: cannot stat %s\n&quot;</span>, path);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里没有像ls一样先判断类型是因为传进来的path一定是路径，</span></span><br><span class="line">    <span class="comment">//不会是文件</span></span><br><span class="line">    <span class="keyword">while</span> (read(fd, &amp;de, <span class="keyword">sizeof</span>(de)) == <span class="keyword">sizeof</span>(de)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (de.inum == <span class="number">0</span>)  <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">strcpy</span>(buf,path);</span><br><span class="line">        p = buf + <span class="built_in">strlen</span>(buf);</span><br><span class="line">        *p++ = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">        memmove(p, de.name, DIRSIZ);</span><br><span class="line">        p[DIRSIZ] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (stat(buf, &amp;st) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;ERROR: cannot stat %s\n&quot;</span>, buf);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span>(st.type) &#123;</span><br><span class="line">            <span class="keyword">case</span> T_DEVICE:</span><br><span class="line">            <span class="keyword">case</span> T_FILE:</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">strcmp</span>(file, de.name) == <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buf);</span><br><span class="line">			&#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> T_DIR:</span><br><span class="line">                <span class="keyword">if</span> ((<span class="built_in">strcmp</span>(de.name, <span class="string">&quot;.&quot;</span>) != <span class="number">0</span>) &amp;&amp; (<span class="built_in">strcmp</span>(de.name, <span class="string">&quot;..&quot;</span>) != <span class="number">0</span>)) &#123;</span><br><span class="line">				    find(buf, file);</span><br><span class="line">                &#125;               </span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里只要仔细看一下xv6中的ls代码，了解struct dirent、struct stat结构体、open、fstat、stat函数的作用就能写出来。</p>
<p>在该程序中，open函数返回path的文件描述符，fstat会将该path的信息传进定义的struct stat类型st中，和ls中不同的是，这里不会先判断类型，因为path一定是传进来的路径而不是文件（不考虑报错的情况下），while循环中每次读取该path下的一个文件（可能是file、directory、device），然后用stat函数将该文件的信息传入st中，接着判断类型，如果是文件就查看是否匹配输入的文件名，如果是目录就递归调用find函数。</p>
<p>注：这里fstat和stat不同的地方在于，传入fstat的是文件描述符和stat，而传入stat的是char*和stat。fstat是一个system call，而stat只是一个普通的函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fstat</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> stat*)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">stat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *n, <span class="keyword">struct</span> stat *st)</span>;</span><br></pre></td></tr></table></figure>

<h2 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h2><p>这个实验我觉得要求给的有点绕，可能是之前不清楚xargs的作用吧，参考了一下别人的代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/param.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/fs.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLEN 20</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> * argv[])</span> &#123;</span><br><span class="line">    <span class="type">char</span>* command = argv[<span class="number">1</span>]; <span class="comment">//grep</span></span><br><span class="line">    <span class="type">char</span> params[MAXARG][MAXLEN];</span><br><span class="line">    <span class="type">char</span> buf;</span><br><span class="line">    <span class="type">char</span>* m[MAXARG];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//外层循环每次执行一个指令</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> count = argc - <span class="number">1</span>;<span class="comment">//</span></span><br><span class="line">        <span class="built_in">memset</span>(params,<span class="number">0</span>,MAXARG * MAXLEN);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; argc; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">strcpy</span>(params[i<span class="number">-1</span>], argv[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> cursor = <span class="number">0</span>; <span class="comment">// 字符串中的位置</span></span><br><span class="line">		<span class="type">int</span> flag = <span class="number">0</span>; <span class="comment">// 空格前是否有参数</span></span><br><span class="line">		<span class="type">int</span> read_result;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//内层循环每次读取一行指令m数组中</span></span><br><span class="line">        <span class="comment">//文件描述符0 是命令行读取</span></span><br><span class="line">        <span class="keyword">while</span> (((read_result = read(<span class="number">0</span>, &amp;buf, <span class="number">1</span>))) &gt; <span class="number">0</span> &amp;&amp; buf != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (buf == <span class="string">&#x27; &#x27;</span> &amp;&amp; flag == <span class="number">1</span>) &#123;</span><br><span class="line">				count++;</span><br><span class="line">				<span class="comment">// reset flag and p</span></span><br><span class="line">				cursor = <span class="number">0</span>;</span><br><span class="line">				flag = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (buf != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">				params[count][cursor++] = buf;</span><br><span class="line">				flag = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// encounters EOF of input or \n</span></span><br><span class="line">		<span class="keyword">if</span> (read_result &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;MAXARG<span class="number">-1</span>; i++) &#123;</span><br><span class="line">			m[i] = params[i];</span><br><span class="line">		&#125;</span><br><span class="line">		m[MAXARG<span class="number">-1</span>] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;</span><br><span class="line">			exec(command, m);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			wait((<span class="type">int</span> *) <span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的关键是，传给xargs中argv[1]是实际要执行的命令，接着程序会循环执行每一条命令行中输入的命令。先把命令行参数依次复制到params数组中，然后再读取标准输入的内容，写入params接下来的位置中（上一步中，params写到params[argc-2],这步从argc-1开始写），读取到换行符或EOF后就fork出子进程执行命令。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/27/Makefile/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Wang Wenhui">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gray's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Gray's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/03/27/Makefile/" class="post-title-link" itemprop="url">Makefile</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-03-27 08:43:54 / 修改时间：17:29:48" itemprop="dateCreated datePublished" datetime="2023-03-27T08:43:54+08:00">2023-03-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CPP/" itemprop="url" rel="index"><span itemprop="name">CPP</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
	<div>
		
	</div>
    <div class="post-body" itemprop="articleBody">
          <h1 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h1><h2 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h2><p>一个Makefile文件由一个<strong>规则</strong>或多个<strong>规则</strong>组成<br>其他规则一般为第一条规则服务</p>
<p><strong>目标 …: 依赖 …<br>    命令（shell命令）<br>    …</strong></p>
<p>目标：最终要生成的文件<br>依赖：生成目标需要的文件或是目标<br>命令：执行命令对依赖操作，生成目标（必须tab缩进）</p>
<p>示例：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">mubiao: yilai1.c yilai2.c yilai3.c</span></span><br><span class="line">	gcc yilai1.c yilai2.c yilai3.c -o mubiao</span><br></pre></td></tr></table></figure>

<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><h6 id="命令在执行之前，需要先检查规则中的依赖是否存在"><a href="#命令在执行之前，需要先检查规则中的依赖是否存在" class="headerlink" title="命令在执行之前，需要先检查规则中的依赖是否存在"></a>命令在执行之前，需要先检查规则中的依赖是否存在</h6><ol>
<li>存在，执行命令</li>
<li>不存在，向下检查其他的规则，查看是否有一个规则是生成这个依赖的，找到就执行这个生成依赖的规则，再执行当前命令</li>
</ol>
<h6 id="检测更新，在执行规则中的命令时，会比较目标和依赖文件的时间"><a href="#检测更新，在执行规则中的命令时，会比较目标和依赖文件的时间" class="headerlink" title="检测更新，在执行规则中的命令时，会比较目标和依赖文件的时间"></a>检测更新，在执行规则中的命令时，会比较目标和依赖文件的时间</h6><ol>
<li>如果依赖的时间比目标的时间晚，需要重新生成目标</li>
<li>如果依赖的时间比目标的时间早，目标不需要更新，对应规则的命令不需要被执行</li>
</ol>
<h6 id="如果有其他规则不会影响到第一条规则的执行，则不会执行"><a href="#如果有其他规则不会影响到第一条规则的执行，则不会执行" class="headerlink" title="如果有其他规则不会影响到第一条规则的执行，则不会执行"></a>如果有其他规则不会影响到第一条规则的执行，则不会执行</h6><p>问题：如果我第一条规则中的依赖需要第二条规则执行，而第二条规则的依赖又需要第三条规则执行，这样可行吗？</p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>自定义变量：<br>    变量名&#x3D;变量值	var&#x3D;hello		$(var)<br>预定义变量：(这部分只能在<strong>命令</strong>中使用)<br>    AR：归档维护程序的名称，默认为ar<br>    CC：C编译器的名称，默认为cc<br>    CXX：C++编译器的名称，默认为g++<br>    $@:	目标的完整名称<br>    $&lt;：第一个依赖文件的名称<br>    $^：所有的依赖文件<br>获取变量的值<br>    $(变量名)</p>
<p>示例：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">app:main.c a.c b.c</span></span><br><span class="line">	gcc -c main.c a.c b.c</span><br><span class="line">	</span><br><span class="line"><span class="section">app:main.c a.c b.c</span></span><br><span class="line">	<span class="variable">$(CC)</span> -c <span class="variable">$^</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure>

<h2 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h2><p>%.o:%.c<br>    %：通配符，匹配一个字符串	两个%匹配的是一个字符串</p>
<p>示例：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">%.o:%.c</span></span><br><span class="line">	gcc -c &amp;&lt; -o &amp;@</span><br></pre></td></tr></table></figure>

<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>$(funcname params)</p>
<p>示例：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">wildcard</span> PATTERN...)</span></span><br><span class="line"><span class="comment">#功能：获取指定目录下指定类型的文件列表</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#参数：PATTERN指的是某个或多个目录下的对应的某种类型的文件，如果有多个目录，一般用空格间隔</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#返回：得到的若干个文件的列表，用空格隔开</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(<span class="built_in">wildcard</span> *.c ./sub/*.c)</span></span><br><span class="line"><span class="comment">#返回格式：a.c b.c c.c d.c e.c f.c</span></span><br></pre></td></tr></table></figure>

<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">patsubst</span> &lt;pattern&gt;,&lt;replacement&gt;,&lt;text&gt;)</span></span><br><span class="line"><span class="comment">#功能：查找&lt;text&gt;中的单词是否符合模式&lt;pattern&gt;，符合就用&lt;replacement&gt;替换</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#&lt;pattern&gt;可以包括通配符&#x27;%&#x27;，表示任意长度的字符串，如果&lt;replacement&gt;中也包含&#x27;%&#x27;,则这个字符串将是前面代表的字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#返回：函数返回被替换过后的字符串</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(<span class="built_in">patsubst</span> %.c, %.o, x.c bar.c)</span></span><br><span class="line"><span class="comment">#返回格式：x.o bar.o</span></span><br></pre></td></tr></table></figure>

<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>可以手动创建命令:</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="keyword">.PHONY</span>:clean</span></span><br><span class="line"><span class="section">make:</span></span><br><span class="line">	rm xxx -f</span><br><span class="line"><span class="comment">#.PHONY表示clean是伪目标，不会生成文件</span></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/23/%E9%9D%99%E6%80%81%E5%BA%93%E5%92%8C%E5%8A%A8%E6%80%81%E5%BA%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Wang Wenhui">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gray's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Gray's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/03/23/%E9%9D%99%E6%80%81%E5%BA%93%E5%92%8C%E5%8A%A8%E6%80%81%E5%BA%93/" class="post-title-link" itemprop="url">静态库和动态库</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-03-23 16:30:10" itemprop="dateCreated datePublished" datetime="2023-03-23T16:30:10+08:00">2023-03-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-03-27 08:34:19" itemprop="dateModified" datetime="2023-03-27T08:34:19+08:00">2023-03-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CPP/" itemprop="url" rel="index"><span itemprop="name">CPP</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
	<div>
		
	</div>
    <div class="post-body" itemprop="articleBody">
          <h1 id="库"><a href="#库" class="headerlink" title="库"></a>库</h1><p> 两种库：静态库和动态库 （共享库）</p>
<p><strong>区别：</strong> 静态库在程序的链接阶段被复制到了程序中；动态库在链接阶段没有被复制到程序中，而是程序在运行时由系统动态加载到内存中供程序调用。</p>
<p><strong>好处：</strong>1、代码保密。2、方便部署和开发</p>
<h2 id="静态库"><a href="#静态库" class="headerlink" title="静态库"></a>静态库</h2><p><em><strong>命名规则：</strong></em></p>
<p>​	Linux：libxxx.a<br>​		lib：前缀（固定）<br>​		xxx：库的名字，自己起<br>​		.a：后缀（固定）</p>
<p>​	Windows：libxxx.lib</p>
<p><em><strong>制作：</strong></em></p>
<p>​	gcc获得.o文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c xxx.c xxx.c xxx.c</span><br></pre></td></tr></table></figure>

<p>​	将.o文件打包，使用ac工具（archive）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ar rcs libxxx.a xxx.o xxx.o</span><br></pre></td></tr></table></figure>

<p>​	r - 将文件插入备存文件中</p>
<p>​	c - 建立备存文件</p>
<p>​	s - 索引</p>
<p><em><strong>使用：</strong></em></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c -o xxx -I 头文件所在文件夹 -l 名字 库所在文件夹 </span><br></pre></td></tr></table></figure>

<h2 id="动态库"><a href="#动态库" class="headerlink" title="动态库"></a>动态库</h2><p><em><strong>命名规则：</strong></em></p>
<p>​	Linux：libxxx.so<br>​		lib：前缀（固定）<br>​		xxx：库的名字，自己起<br>​		.so：后缀（固定）<br>​		在Linux下是一个可执行文件</p>
<p>​	Windows：libxxx.dll</p>
<p><em><strong>制作：</strong></em></p>
<p>​	gcc获得.o文件，<strong>得到和位置无关的代码</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c -fpic/-fPIC xxx.c xxx.c</span><br></pre></td></tr></table></figure>

<p>​	gcc得到动态库</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -shared xxx.o xxx.o -o libxxx.so</span><br></pre></td></tr></table></figure>

<p><em><strong>使用：</strong></em></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c -o xxx -I 头文件所在文件夹 -L 库所在文件夹 -l 名字</span><br></pre></td></tr></table></figure>

<p> 发现运行不了，因为系统要知道绝对路径</p>
<p>第一种方法：修改环境变量LD_LIBRARY_PATH</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:要添加的文件夹目录</span><br></pre></td></tr></table></figure>

<p>永久配置：</p>
<p>用户配置：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vim .bashrc</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">进入了.bashrc 用vim编辑 在末尾增加</span></span><br><span class="line">export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:要添加的路径</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">保存 然后<span class="built_in">source</span></span></span><br><span class="line"></span><br><span class="line">source .bashrc</span><br></pre></td></tr></table></figure>

<p>系统配置：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/profile</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">在末尾增加</span></span><br><span class="line">export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:要添加的路径</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">保存 然后<span class="built_in">source</span></span></span><br><span class="line"></span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure>

<p>第二种方法：修改&#x2F;etc&#x2F;ld.so.cache文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/ld.so.conf</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">把路径写在里面就行，然后保存退出，更新</span></span><br><span class="line"></span><br><span class="line">sudo ldconfig</span><br></pre></td></tr></table></figure>

<p>第三种方法：把库文件放在&#x2F;lib&#x2F;或&#x2F;usr&#x2F;lib目录下（不推荐）</p>
<h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p><strong>静态库：</strong><br>    优点：<br>        · 被打包到应用程序中加载速度快<br>        · 发布程序不用提供静态库，移植方便</p>
<p>​	缺点：<br>​		· 消耗系统资源，浪费内存<br>​		· 更新、部署、发布麻烦</p>
<p><strong>动态库：</strong><br>    优点：<br>        · 可以实现进程间资源共享<br>        · 更新、部署、发布简单<br>        · 可以控制何时加载动态库</p>
<p>​	缺点：<br>​		· 加载速度比静态库慢<br>​		· 发布程序时需要提供依赖的动态库</p>
<p>之前写过一次贪吃蛇，打包给同学试试的时候，用静态库所有同学都能玩，而用动态库有些同学就玩不了了，就是这个道理。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/11/CPP%E5%A4%A7%E5%B0%8F%E6%A0%B9%E5%A0%86-priority-queue/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Wang Wenhui">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gray's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Gray's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/03/11/CPP%E5%A4%A7%E5%B0%8F%E6%A0%B9%E5%A0%86-priority-queue/" class="post-title-link" itemprop="url">CPP大小根堆-priority_queue</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-03-11 14:44:25 / 修改时间：16:42:56" itemprop="dateCreated datePublished" datetime="2023-03-11T14:44:25+08:00">2023-03-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
	<div>
		
	</div>
    <div class="post-body" itemprop="articleBody">
          <h1 id="概述和模板定义"><a href="#概述和模板定义" class="headerlink" title="概述和模板定义"></a>概述和模板定义</h1><p>priority_queue容器在头文件<queue>中，位于std命名空间中,容器是有序的。</p>
<p>模板定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;	<span class="keyword">typename</span> T,							<span class="comment">//容器中元素的类型</span></span><br><span class="line">        	<span class="keyword">typename</span> Container=std::vector&lt;T&gt;,	<span class="comment">//底层使用的容器，vector或</span></span><br><span class="line">												<span class="comment">//deque</span></span><br><span class="line">        	<span class="keyword">typename</span> Compare=std::less&lt;T&gt; &gt;	<span class="comment">//排序规则</span></span><br><span class="line">                							<span class="comment">//std::less&lt;T&gt; 		从大到小</span></span><br><span class="line">                							<span class="comment">//std::greater&lt;T&gt;	从小到大</span></span><br><span class="line">                							<span class="comment">//还可以自定义规则，做题一般不用</span></span><br><span class="line"><span class="keyword">class</span> priority_queue&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="创建容器的方法"><a href="#创建容器的方法" class="headerlink" title="创建容器的方法"></a>创建容器的方法</h1><p>最基本的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::priority_queue&lt;<span class="type">int</span>&gt; values;</span><br></pre></td></tr></table></figure>

<p>使用普通数组或其他容器：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用普通数组</span></span><br><span class="line"><span class="type">int</span> values[]&#123;<span class="number">4</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="function">std::priority_queue&lt;<span class="type">int</span>&gt; <span class="title">copy_values</span><span class="params">(values,values+<span class="number">4</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用序列式容器</span></span><br><span class="line">std::array&lt;<span class="type">int</span>,4&gt;values&#123; <span class="number">4</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span> &#125;;</span><br><span class="line"><span class="function">std::priority_queue&lt;<span class="type">int</span>&gt; <span class="title">copy_values</span><span class="params">(values.begin(),values.end())</span></span>;</span><br></pre></td></tr></table></figure>

<p>手动指定：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> values[]&#123; <span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;;</span><br><span class="line">std::priority_queue&lt;<span class="type">int</span>, std::deque&lt;<span class="type">int</span>&gt;, std::greater&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">copy_values</span>(values, values+<span class="number">4</span>);</span><br></pre></td></tr></table></figure>

<h1 id="常用成员函数"><a href="#常用成员函数" class="headerlink" title="常用成员函数"></a>常用成员函数</h1><table>
<thead>
<tr>
<th>成员函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>empty()</td>
<td>如果 priority_queue 为空的话，返回 true；反之，返回 false。</td>
</tr>
<tr>
<td>size()</td>
<td>返回 priority_queue 中存储元素的个数。</td>
</tr>
<tr>
<td>top()</td>
<td>返回 priority_queue 中第一个元素的引用形式。</td>
</tr>
<tr>
<td>push(const T&amp; obj)</td>
<td>根据既定的排序规则，将元素 obj 的副本存储到 priority_queue 中适当的位置。</td>
</tr>
<tr>
<td>push(T&amp;&amp; obj)</td>
<td>根据既定的排序规则，将元素 obj 移动存储到 priority_queue 中适当的位置。</td>
</tr>
<tr>
<td>emplace(Args&amp;&amp;… args)</td>
<td>Args&amp;&amp;… args 表示构造一个存储类型的元素所需要的数据（对于类对象来说，可能需要多个数据构造出一个对象）。此函数的功能是根据既定的排序规则，在容器适配器适当的位置直接生成该新元素。</td>
</tr>
<tr>
<td>pop()</td>
<td>移除 priority_queue 容器适配器中第一个元素。</td>
</tr>
<tr>
<td>swap(priority_queue<T>&amp; other)</td>
<td>将两个 priority_queue 容器适配器中的元素进行互换，需要注意的是，进行互换的 2 个 priority_queue 容器适配器中存储的元素类型以及底层采用的基础容器类型，都必须相同。</td>
</tr>
</tbody></table>
<p>适用于题目：（待补充）</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/6987.html">http://c.biancheng.net/view/6987.html</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/10/%E5%AE%9A%E6%97%B6%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Wang Wenhui">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gray's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Gray's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/03/10/%E5%AE%9A%E6%97%B6%E5%99%A8/" class="post-title-link" itemprop="url">定时器</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-03-10 10:39:07" itemprop="dateCreated datePublished" datetime="2023-03-10T10:39:07+08:00">2023-03-10</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
	<div>
		
	</div>
    <div class="post-body" itemprop="articleBody">
          
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/09/HTTP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Wang Wenhui">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gray's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Gray's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/03/09/HTTP/" class="post-title-link" itemprop="url">HTTP</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-03-09 17:08:50" itemprop="dateCreated datePublished" datetime="2023-03-09T17:08:50+08:00">2023-03-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-03-11 21:31:59" itemprop="dateModified" datetime="2023-03-11T21:31:59+08:00">2023-03-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/TinyWebServer/" itemprop="url" rel="index"><span itemprop="name">TinyWebServer</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
	<div>
		
	</div>
    <div class="post-body" itemprop="articleBody">
          <h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h2><p>epoll是一种I&#x2F;O事件通知机制</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//该函数创建一个指示epoll内核事件表的文件描述符，</span></span><br><span class="line"><span class="comment">//描述符将用作其他epoll系统调用的第一个参数，size不起作用</span></span><br><span class="line"><span class="comment">//这里不懂size为什么不起作用</span></span><br><span class="line"><span class="comment">//查了一下，size参数表示所要监视文件描述符的最大值，不过在后来的Linux版本中已经被弃用（同时，size不要传0，会报invalid argument错误）</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_create</span><span class="params">(<span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//该函数操作内核事件表监控的文件描述符上的事件：注册、修改、删除</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span></span></span><br><span class="line"><span class="function"><span class="comment">//· epfd：epoll_create的句柄</span></span></span><br><span class="line"><span class="function"><span class="comment">//· op：表示动作，用3个宏表示：</span></span></span><br><span class="line"><span class="function"><span class="comment">//	· EPOLL_CTL_ADD(注册新的fd到epfd)</span></span></span><br><span class="line"><span class="function"><span class="comment">//  · EPOLL_CTL_MOD(修改已经注册的fd的监听事件)</span></span></span><br><span class="line"><span class="function"><span class="comment">//  · EPOLL_CTL_DEL(从epfd删除一个fd)</span></span></span><br><span class="line"><span class="function"><span class="comment">//· event：告诉内核需要监听的事件</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">//epoll_event的定义</span></span></span><br><span class="line"><span class="function"><span class="keyword">struct</span> epoll_event </span>&#123;</span><br><span class="line">    <span class="type">_uint32_t</span> events;</span><br><span class="line">    <span class="type">epoll_data_t</span> data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//epoll_data_t</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> <span class="title class_">epoll_data</span> &#123;</span><br><span class="line">    <span class="type">void</span> *ptr; <span class="comment">/* 指向用户自定义数据 */</span></span><br><span class="line">    <span class="type">int</span> fd; <span class="comment">/* 注册的文件描述符 */</span></span><br><span class="line">    <span class="type">uint32_t</span> u32; <span class="comment">/* 32-bit integer */</span></span><br><span class="line">    <span class="type">uint64_t</span> u64; <span class="comment">/* 64-bit integer */</span></span><br><span class="line">&#125; <span class="type">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">events描述事件类型，其中epoll事件类型有以下几种:</span></span><br><span class="line"><span class="comment">· EPOLLIN：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）</span></span><br><span class="line"><span class="comment">· EPOLLOUT：表示对应的文件描述符可以写</span></span><br><span class="line"><span class="comment">· EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）</span></span><br><span class="line"><span class="comment">· EPOLLERR：表示对应的文件描述符发生错误</span></span><br><span class="line"><span class="comment">· EPOLLHUP：表示对应的文件描述符被挂断；</span></span><br><span class="line"><span class="comment">· EPOLLET：将EPOLL设为边缘触发（Edge Triggered)模式，这是相对于水平触发		(Level Triggered)而言的</span></span><br><span class="line"><span class="comment">· EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个		socket的话，需要再次把这个socket加入到EPOLL队列里 </span></span><br><span class="line"><span class="comment">· EPOLLRDHUP：对端描述符产生一个挂断事件</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//该函数用于等待所监控文件描述符上有事件的产生，返回就绪的文件描述符个数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event *event, <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">· events：用来存内核得到事件的集合	应该是一个数组</span></span><br><span class="line"><span class="function">· maxevents：告之内核这个events有多大，这个maxevents的值不能大于				epoll_create（）时的size</span></span><br><span class="line"><span class="function">· timeout：是超时时间</span></span><br><span class="line"><span class="function">	· -1：调用一直阻塞，直到有文件描述符进入ready状态或捕获到信号才返回</span></span><br><span class="line"><span class="function">	· 0：用于非阻塞检测是否有描述符处于ready状态，不管结果如何，调用都立即返回</span></span><br><span class="line"><span class="function">	· &gt;0：指定毫秒，期间有检测对象变为ready状态或捕获到信号返回，否则直到超时</span></span><br><span class="line"><span class="function">· 返回值：成功返回有多少文件描述符就绪，时间到时返回0，出错返回-1</span></span><br></pre></td></tr></table></figure>

<h5 id="select-x2F-poll-x2F-epoll对比"><a href="#select-x2F-poll-x2F-epoll对比" class="headerlink" title="select&#x2F;poll&#x2F;epoll对比"></a>select&#x2F;poll&#x2F;epoll对比</h5><p><strong>调用函数：</strong></p>
<p>​	· select和poll都是一个函数，epoll是一组函数</p>
<p><strong>文件描述符数量及传入方式：</strong></p>
<p>​	· select通过线性表描述文件描述符集合，文件描述符有上限，一般是1024，但可以修	改源码，重新编译内核，不推荐。传入方式：创建3个文件描述符拷贝到内核中。</p>
<p>​	· poll是链表描述，突破了文件描述符上限，最大可以打开文件的数目（这里意思是说系统最大的数目？）。传入方式：将传入的struct pollfd结构体数组拷贝到内核中进行监听</p>
<p>​	· epoll通过红黑树描述，最大可以打开文件的数目，可以通过命令ulimit -n number修	改，仅对当前终端有效。传入方式：epoll通过epoll_create建立一棵红黑树，通过epoll_ctl将要监听的文件描述符注册到红黑树。</p>
<p><strong>内核态检测文件描述符读写状态的方式：</strong></p>
<p>​	· select：采用轮询方式，遍历所有fd，最后返回一个描述符读写操作是否就绪的mask掩码，根据掩码给fd_set赋值。</p>
<p>​	· poll：采用轮询方式，查询每个fd的状态，如果就绪则在等待队列中加入一项并继续遍历</p>
<p>​	· epoll：采用回调机制，在执行epoll_ctl的add操作时，不仅将文件描述符放到红黑树上，而且也注册了回调函数，内核在检测到某文件描述符可读&#x2F;可写时会调用回调函数，该回调函数将文件描述符放在就绪链表中，当epoll_wait函数调用时，仅仅观察这个list链表里有没有数据即可。只有发生了事件的socket才会主动的去调用 callback函数，其他空闲状态socket则不会，若是就绪事件，插入list。</p>
<p><strong>找到就绪的文件描述符并传递给用户态的方式:</strong></p>
<p>​	· select：将之前传入的fd_set拷贝传出到用户态并返回就绪的文件描述符总数。用户态并不知道是哪些文件描述符处于就绪态，需要遍历来判断。</p>
<p>​	· poll：将之前传入的fd数组拷贝传出到用户态并返回就绪的文件描述符总数。用户态并不知道是哪些文件描述符处于就绪态，需要遍历来判断。</p>
<p>​	· epoll：epoll返回的发生了事件的个数和结构体数组，结构体包含socket的信息，因此直接处理返回的数组即可，然后遍历依次处理即可。</p>
<p><strong>重复监听的处理方式:</strong></p>
<p>​	· select：将新的监听文件描述符集合拷贝传入内核中，继续以上步骤</p>
<p>​	· poll：将新的struct pollfd结构体数组拷贝传入内核中，继续以上步骤。</p>
<p>​	· epoll：无需重新构建红黑树，直接沿用已存在的即可。</p>
<p><strong>工作模式：</strong></p>
<p>​	· select和poll都只能工作在相对低效的LT模式下。</p>
<p>​	· epoll则可以工作在ET高效模式，并且epoll还支持EPOLLONESHOT事件，该事件能进一步减少可读、可写和异常事件被触发的次数。 </p>
<p><strong>应用场景：</strong></p>
<p>​	· 当所有的fd都是活跃连接，使用epoll，需要建立文件系统，红黑书和链表对于此来说，效率反而不高，不如selece和poll。</p>
<p>​	· 当监测的fd数目较小，且各个fd都比较活跃，建议使用select或者poll。</p>
<p>​	· 当监测的fd数目非常大，成千上万，且单位时间只有其中的一部分fd处于就绪状态，这个时候使用epoll能够明显提升性能。</p>
<h5 id="ET、LT、EPOLLONESHOT"><a href="#ET、LT、EPOLLONESHOT" class="headerlink" title="ET、LT、EPOLLONESHOT"></a>ET、LT、EPOLLONESHOT</h5><p>​	· LT水平触发模式触发时机：</p>
<ol>
<li>对于读操作，只要缓冲内容不为空，LT模式返回读就绪。</li>
<li>对于写操作，只要缓冲区还不满，LT模式会返回写就绪。</li>
</ol>
<p>当被监控的文件描述符上有可读写事件发生时，epoll_wait()会通知处理程序去读写。如果这次没有把数据一次性全部读写完(如读写缓冲区太小)，那么下次调用 epoll_wait()时，它还会通知你在上没读写完的文件描述符上继续读写，当然如果你一直不去读写，它会一直通知你。如果系统中有大量你不需要读写的就绪文件描述符，而它们每次都会返回，这样会大大降低处理程序检索自己关心的就绪文件描述符的效率。</p>
<p>​	· ET边缘触发模式触发时机：</p>
<p>​		对于读操作：							</p>
<pre><code> 1. 当缓冲区由不可读变为可读的时候，即缓冲区由空变为不空的时候。
 2. 当有新数据到达时，即缓冲区中的待读数据变多的时候。
 3. 当缓冲区有数据可读，且应用进程对相应的描述符进行EPOLL_CTL_MOD 修改EPOLLIN事件时。
</code></pre>
<p>​		对于写操作：</p>
<pre><code> 1. 当缓冲区由不可写变为可写时。
 2. 当有旧数据被发送走，即缓冲区中的内容变少的时候。
 3. 当缓冲区有空间可写，且应用进程对相应的描述符进行EPOLL_CTL_MOD 修改EPOLLOUT事件时。
</code></pre>
<p>epoll_wait检测到文件描述符有事件发生，则将其通知给应用程序，应用程序必须立即处理该事</p>
<p>必须要一次性将数据读取完，使用非阻塞I&#x2F;O，读取到出现eagai</p>
<p>EPOLLONESHOT</p>
<p>一个线程读取某个socket上的数据后开始处理数据，在处理过程中该socket上又有新数据可读，此时另一个线程被唤醒读取，此时出现两个线程处理同一个socket</p>
<p>我们期望的是一个socket连接在任一时刻都只被一个线程处理，通过epoll_ctl对该文件描述符注册epolloneshot事件，一个线程处理socket时，其他线程将无法处理，<strong>当该线程处理完后，需要通过epoll_ctl重置epolloneshot事件</strong></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/02/11/wsl%E5%AE%89%E8%A3%85mysql/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Wang Wenhui">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gray's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Gray's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/02/11/wsl%E5%AE%89%E8%A3%85mysql/" class="post-title-link" itemprop="url">wsl安装mysql</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-02-11 14:01:40 / 修改时间：14:40:29" itemprop="dateCreated datePublished" datetime="2023-02-11T14:01:40+08:00">2023-02-11</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
	<div>
		
	</div>
    <div class="post-body" itemprop="articleBody">
          <p>整个流程参照<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/373254891">https://zhuanlan.zhihu.com/p/373254891</a></p>
<h4 id="安装mysql"><a href="#安装mysql" class="headerlink" title="安装mysql"></a>安装mysql</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update;</span><br><span class="line">sudo apt-get install mysql-server</span><br></pre></td></tr></table></figure>

<p>这里第一步更新我就出了问题，报错大概是</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line"></span><br><span class="line">E: Could not get lock /var/lib/apt/lists/lock - open (11: Resource temporarily unavailable)</span><br><span class="line">E: Unable to lock directory /var/lib/apt/lists/</span><br></pre></td></tr></table></figure>

<p>然后搜了一下<a target="_blank" rel="noopener" href="https://www.cnblogs.com/qq952693358/p/6537846.html%EF%BC%8C%E5%8F%AF%E8%83%BD%E6%98%AF%E6%9C%89%E4%B8%AA%E8%BF%9B%E7%A8%8B%E6%AD%A3%E5%9C%A8apt-get%EF%BC%8C%E9%9C%80%E8%A6%81kill%E6%8E%89%E8%BF%9B%E7%A8%8B">https://www.cnblogs.com/qq952693358/p/6537846.html，可能是有个进程正在apt-get，需要kill掉进程</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">rm</span> /var/lib/apt/lists/lock</span><br></pre></td></tr></table></figure>

<p>然后再更新就好了，继续sudo apt-get install mysql-server也没问题</p>
<h4 id="启动mysql服务"><a href="#启动mysql服务" class="headerlink" title="启动mysql服务"></a>启动mysql服务</h4><p>有以下几个指令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#check the status of mysql </span></span><br><span class="line">sudo service mysql status</span><br><span class="line"></span><br><span class="line"><span class="comment">#start mysql </span></span><br><span class="line">sudo service mysql start  </span><br><span class="line"></span><br><span class="line"><span class="comment">#stop mysql </span></span><br><span class="line">sudo service mysql stop  </span><br><span class="line"></span><br><span class="line"><span class="comment">#restart msyql </span></span><br><span class="line">sudo service mysql restart</span><br></pre></td></tr></table></figure>

<p>先查看一下状态</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graywenhui@Grays-LAPTOP:~$ service mysql status</span><br><span class="line"> </span><br><span class="line"> <span class="comment">#下面是信息</span></span><br><span class="line"> * MySQL is stopped.</span><br></pre></td></tr></table></figure>

<p>然后启动</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graywenhui@Grays-LAPTOP:~$ sudo service mysql start</span><br><span class="line"></span><br><span class="line"><span class="comment">#下面是信息</span></span><br><span class="line"> * Starting MySQL database server mysqld                                                         su: warning: cannot change directory to /nonexistent: No such file or directory</span><br></pre></td></tr></table></figure>

<p>又报错了，继续搜<a target="_blank" rel="noopener" href="https://www.cnblogs.com/cnwcl/p/13805643.html%EF%BC%8C%E5%8F%91%E7%8E%B0%E5%8F%AF%E8%83%BD%E6%98%AFmysql%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%82%E5%B8%B8%E5%85%B3%E6%9C%BA%E5%AF%BC%E8%87%B4%E7%9A%84%EF%BC%8C%E4%B8%8D%E8%BF%87%E6%88%91%E6%89%8D%E5%88%9A%E8%A3%85%E4%B8%8A%EF%BC%8C%E6%9C%89%E7%82%B9%E5%A5%87%E6%80%AA%E3%80%82%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9A">https://www.cnblogs.com/cnwcl/p/13805643.html，发现可能是mysql服务器异常关机导致的，不过我才刚装上，有点奇怪。解决方案：</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">graywenhui@Grays-LAPTOP:~$ sudo service mysql stop</span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"> * Stopping MySQL database server mysqld                                                  [ OK ] </span><br><span class="line">graywenhui@Grays-LAPTOP:~$ sudo usermod -d /var/lib/mysql/ mysql</span><br><span class="line"></span><br><span class="line">graywenhui@Grays-LAPTOP:~$ sudo service mysql start</span><br><span class="line">[sudo] password <span class="keyword">for</span> graywenhui: <span class="comment">#这里键入wsl密码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"> * Starting MySQL database server mysqld</span><br></pre></td></tr></table></figure>

<p>成功了！</p>
<h4 id="修改root密码"><a href="#修改root密码" class="headerlink" title="修改root密码"></a>修改root密码</h4><p>安装完mysql提供了一个默认的登录用户与密码，可以这样看</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">graywenhui@Grays-LAPTOP:~$ sudo <span class="built_in">cat</span> /etc/mysql/debian.cnf</span><br><span class="line"></span><br><span class="line"><span class="comment">#下面是信息</span></span><br><span class="line"><span class="comment"># Automatically generated for Debian scripts. DO NOT TOUCH!</span></span><br><span class="line">[client]</span><br><span class="line">host     = localhost</span><br><span class="line">user     = debian-sys-maint</span><br><span class="line">password = vdjgK18b5Y4RNk2Q</span><br><span class="line">socket   = /var/run/mysqld/mysqld.sock</span><br><span class="line">[mysql_upgrade]</span><br><span class="line">host     = localhost</span><br><span class="line">user     = debian-sys-maint</span><br><span class="line">password = vdjgK18b5Y4RNk2Q</span><br><span class="line">socket   = /var/run/mysqld/mysqld.sock</span><br></pre></td></tr></table></figure>

<p>[mysql_upgrade]下面的user和password就是mysql的用户和密码了，通过这两进行登录：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">graywenhui@Grays-LAPTOP:~$ sudo mysql -udebian-sys-maint -pvdjgK18b5Y4RNk2Q</span><br><span class="line"></span><br><span class="line"><span class="comment">#下面是信息</span></span><br><span class="line">mysql: [Warning] Using a password on the <span class="built_in">command</span> line interface can be insecure.</span><br><span class="line">Welcome to the MySQL monitor.  Commands end with ; or \g.</span><br><span class="line">Your MySQL connection <span class="built_in">id</span> is 10</span><br><span class="line">Server version: 8.0.32-0ubuntu0.20.04.2 (Ubuntu)</span><br><span class="line"></span><br><span class="line">Copyright (c) 2000, 2023, Oracle and/or its affiliates.</span><br><span class="line"></span><br><span class="line">Oracle is a registered trademark of Oracle Corporation and/or its</span><br><span class="line">affiliates. Other names may be trademarks of their respective</span><br><span class="line">owners.</span><br><span class="line"></span><br><span class="line">Type <span class="string">&#x27;help;&#x27;</span> or <span class="string">&#x27;\h&#x27;</span> <span class="keyword">for</span> <span class="built_in">help</span>. Type <span class="string">&#x27;\c&#x27;</span> to clear the current input statement.</span><br><span class="line"></span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure>

<p>这样就进入到了mysql中，然后切换到mysql对root的密码进行修改：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#选择database</span></span><br><span class="line">mysql&gt; use mysql;</span><br><span class="line"><span class="comment">#</span></span><br><span class="line">Reading table information <span class="keyword">for</span> completion of table and column names</span><br><span class="line">You can turn off this feature to get a quicker startup with -A</span><br><span class="line"></span><br><span class="line">Database changed</span><br><span class="line"></span><br><span class="line"><span class="comment">#更新密码</span></span><br><span class="line">mysql&gt; alter user <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> identified with mysql_native_password by <span class="string">&#x27;这里填你想要的密码&#x27;</span>;</span><br><span class="line"><span class="comment">#</span></span><br><span class="line">Query OK, 0 rows affected (0.02 sec)</span><br><span class="line"></span><br><span class="line"><span class="comment">#write privileges</span></span><br><span class="line">mysql&gt; flush privileges;</span><br><span class="line"><span class="comment">#</span></span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"></span><br><span class="line"><span class="comment">#然后就可以键入quit退出mysql模式了</span></span><br><span class="line">mysql&gt; quit</span><br></pre></td></tr></table></figure>

<p>然后可以重启一下mysql服务，再用mysql -uroot -p’你刚填的密码‘（注意这里的’‘要去掉，上面的’‘要保留），然后就好了</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/02/10/%E5%8D%8A%E5%90%8C%E6%AD%A5%E5%8D%8A%E5%8F%8D%E5%BA%94%E5%A0%86%E7%BA%BF%E7%A8%8B%E6%B1%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Wang Wenhui">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gray's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Gray's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/02/10/%E5%8D%8A%E5%90%8C%E6%AD%A5%E5%8D%8A%E5%8F%8D%E5%BA%94%E5%A0%86%E7%BA%BF%E7%A8%8B%E6%B1%A0/" class="post-title-link" itemprop="url">半同步半反应堆线程池</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-02-10 22:13:45" itemprop="dateCreated datePublished" datetime="2023-02-10T22:13:45+08:00">2023-02-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-03-09 17:12:42" itemprop="dateModified" datetime="2023-03-09T17:12:42+08:00">2023-03-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/TinyWebServer/" itemprop="url" rel="index"><span itemprop="name">TinyWebServer</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
	<div>
		
	</div>
    <div class="post-body" itemprop="articleBody">
          <h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><h2 id="服务器编程基本框架"><a href="#服务器编程基本框架" class="headerlink" title="服务器编程基本框架"></a>服务器编程基本框架</h2><p>主要由I&#x2F;O单元，逻辑单元和网络存储单元组成，其中每个单元之间通过请求队列进行通信，从而协同完成任务。</p>
<p>I&#x2F;O队列：处理客户端连接，读写网络数据<br>逻辑单元：处理业务逻辑的线程<br>网络存储单元：指本地数据库和文件等</p>
<p><img src="https://cdn.jsdelivr.net/gh/graywenhui/blogImage@main/img/202302102229727.png" alt="image-20230210222856140"></p>
<h2 id="五种I-x2F-O模型"><a href="#五种I-x2F-O模型" class="headerlink" title="五种I&#x2F;O模型"></a>五种I&#x2F;O模型</h2><h5 id="阻塞IO"><a href="#阻塞IO" class="headerlink" title="阻塞IO"></a>阻塞IO</h5><p>调用者调用了某个函数，等待这个函数返回，期间什么也不做，不停的去检查这个函数有没有返回，必须等待返回才能进行下一步</p>
<h5 id="非阻塞IO"><a href="#非阻塞IO" class="headerlink" title="非阻塞IO"></a>非阻塞IO</h5><p>非阻塞等待，每隔一段时间就去检测IO事件是否就绪。没有就绪就可以做其他事。非阻塞I&#x2F;O执行系统调用总是立即返回，不管事件是否已经发生，若事件没有发生，则返回-1，此时可以根据errno区分这两种情况，对于accept，recv和send，事件未发生时，errno通常被设置成eagain</p>
<h5 id="信号驱动IO"><a href="#信号驱动IO" class="headerlink" title="信号驱动IO"></a>信号驱动IO</h5><p>linux用套接口进行信号驱动IO，安装一个信号处理函数，进程继续运行并不阻塞，当IO时间就绪，进程收到SIGIO信号。然后处理IO事件</p>
<h5 id="IO复用"><a href="#IO复用" class="headerlink" title="IO复用"></a>IO复用</h5><p>linux用select&#x2F;poll函数实现IO复用模型，这两个函数也会使进程阻塞，但是和阻塞IO所不同的是这两个函数可以同时阻塞多个IO操作。而且可以同时对多个读操作、写操作的IO函数进行检测。知道有数据可读或可写时，才真正调用IO操作函数</p>
<h5 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h5><p>linux中，可以调用aio_read函数告诉内核描述字缓冲区指针和缓冲区的大小、文件偏移及通知的方式，然后立即返回，当内核将数据拷贝到缓冲区后，再通知应用程序</p>
<p>前四种都是同步IO，同步I&#x2F;O指内核向应用程序通知的是就绪事件，比如只通知有客户端连接，要求用户代码自行执行I&#x2F;O操作，异步I&#x2F;O是指内核向应用程序通知的是完成事件，比如读取客户端的数据后才通知应用程序，由内核完成I&#x2F;O操作。</p>
<p>这里不是很清楚，参考这个回答<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/19732473%E6%AF%94%E8%BE%83%E6%B8%85%E6%A5%9A">https://www.zhihu.com/question/19732473比较清楚</a></p>
<h2 id="事件处理模式"><a href="#事件处理模式" class="headerlink" title="事件处理模式"></a>事件处理模式</h2><h5 id="reactor模式"><a href="#reactor模式" class="headerlink" title="reactor模式"></a>reactor模式</h5><p>主线程(<strong>I&#x2F;O处理单元</strong>)只负责监听文件描述符上是否有事件发生，有的话立即通知工作线程(<strong>逻辑单元</strong> )，读写数据、接受新连接及处理客户请求均在工作线程中完成。通常由<strong>同步I&#x2F;O</strong>实现</p>
<h5 id="proactor模式"><a href="#proactor模式" class="headerlink" title="proactor模式"></a>proactor模式</h5><p>主线程和内核负责处理读写数据、接受新连接等I&#x2F;O操作，工作线程仅负责业务逻辑，如处理客户请求。通常由<strong>异步I&#x2F;O</strong>实现</p>
<h2 id="同步I-x2F-O模拟proactor模式"><a href="#同步I-x2F-O模拟proactor模式" class="headerlink" title="同步I&#x2F;O模拟proactor模式"></a>同步I&#x2F;O模拟proactor模式</h2><p>同步I&#x2F;O模型工作流程如下（epoll_wait为例）：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">主线程往epoll内核事件表注册socket上的读就绪事件。</span><br><span class="line"></span><br><span class="line">主线程调用epoll<span class="emphasis">_wait等待socket上有数据可读</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">当socket上有数据可读，epoll_</span>wait通知主线程,主线程从socket循环读取数据，直到没有更多数据可读，然后将读取到的数据封装成一个请求对象并插入请求队列。</span><br><span class="line"></span><br><span class="line">睡眠在请求队列上某个工作线程被唤醒，它获得请求对象并处理客户请求，然后往epoll内核事件表中注册该socket上的写就绪事件</span><br><span class="line"></span><br><span class="line">主线程调用epoll<span class="emphasis">_wait等待socket可写。</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">当socket上有数据可写，epoll_</span>wait通知主线程。主线程往socket上写入服务器处理客户请求的结果。</span><br></pre></td></tr></table></figure>

<h2 id="并发编程模式"><a href="#并发编程模式" class="headerlink" title="并发编程模式"></a>并发编程模式</h2><p>并发编程方法的实现有多线程和多进程两种。这里的并发模式指I&#x2F;O处理单元与逻辑单元的协同完成任务的方法<br>· 半同步&#x2F;半异步模式<br>· 领导者&#x2F;追随者模式</p>
<h2 id="半同步-x2F-半反应堆"><a href="#半同步-x2F-半反应堆" class="headerlink" title="半同步&#x2F;半反应堆"></a>半同步&#x2F;半反应堆</h2><p>半同步&#x2F;半反应堆并发模式是半同步&#x2F;半异步的变体，将半异步具体化为某种事件处理模式</p>
<p>并发模式中的同步和异步：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">同步指的是程序完全按照代码序列的顺序执行</span><br><span class="line"></span><br><span class="line">异步指的是程序的执行需要由系统事件驱动</span><br></pre></td></tr></table></figure>

<p>半同步&#x2F;半异步模式工作流程:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">同步线程用于处理客户逻辑</span><br><span class="line"></span><br><span class="line">异步线程用于处理I/O事件</span><br><span class="line"></span><br><span class="line">异步线程监听到客户请求后，就将其封装成请求对象并插入请求队列中</span><br><span class="line"></span><br><span class="line">请求队列将通知某个工作在同步模式的工作线程来读取并处理该请求对象</span><br></pre></td></tr></table></figure>

<p>半同步&#x2F;半反应堆工作流程（以Proactor模式为例）:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">线程充当异步线程，负责监听所有socket上的事件</span><br><span class="line"></span><br><span class="line">若有新请求到来，主线程接收之以得到新的连接socket，然后往epoll内核事件表中注册该socket上的读写事件</span><br><span class="line"></span><br><span class="line">如果连接socket上有读写事件发生，主线程从socket上接收数据，并将数据封装成请求对象插入到请求队列中</span><br><span class="line"></span><br><span class="line">所有工作线程睡眠在请求队列上，当有任务到来时，通过竞争（如互斥锁）获得任务的接管权</span><br></pre></td></tr></table></figure>

<h2 id="线程池-1"><a href="#线程池-1" class="headerlink" title="线程池"></a>线程池</h2><p>空间换时间,浪费服务器的硬件资源,换取运行效率</p>
<p>池是一组资源的集合,这组资源在服务器启动之初就被完全创建好并初始化,这称为静态资源</p>
<p>当服务器进入正式运行阶段,开始处理客户请求的时候,如果它需要相关的资源,可以直接从池中获取,无需动态分配</p>
<p>当服务器处理完一个客户连接后,可以把相关的资源放回池中,无需执行系统调用释放资源</p>
<h2 id="pthread-create陷阱"><a href="#pthread-create陷阱" class="headerlink" title="pthread_create陷阱"></a>pthread_create陷阱</h2><p>函数原型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_create</span> <span class="params">(<span class="type">pthread_t</span> *thread_tid,                 <span class="comment">//返回新生成的线程的id</span></span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr,         <span class="comment">//指向线程属性的指针,通常设置为NULL</span></span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="type">void</span> * (*start_routine) (<span class="type">void</span> *),   <span class="comment">//处理线程函数的地址</span></span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="type">void</span> *arg)</span></span>;                         <span class="comment">//start_routine()中的参数</span></span><br></pre></td></tr></table></figure>

<p>第三个参数是函数指针，指向处理线程函数的地址。该函数，要求为静态函数。如果处理线程函数是类成员函数，则需要将其设置为静态成员函数。</p>
<p>要这样做的原因是：pthread_create的函数原型中第三个参数的类型为函数指针，指向的线程处理函数参数类型为<code>(void *)</code>,若线程函数为类成员函数，则this指针会作为默认的参数被传进函数中，从而和线程函数参数<code>(void*)</code>不能匹配，不能通过编译。而静态成员函数没有this指针，就没有这个问题</p>
<h2 id="线程池分析"><a href="#线程池分析" class="headerlink" title="线程池分析"></a>线程池分析</h2><p>线程池的设计模式为半同步&#x2F;半反应堆，其中反应堆具体为Proactor事件处理模式。</p>
<p>具体的，主线程为异步线程，负责监听文件描述符，接收socket新连接，若当前监听的socket发生了读写事件，然后将任务插入到请求队列。工作线程从请求队列中取出任务，完成读写数据的处理。</p>
<h5 id="线程池类定义"><a href="#线程池类定义" class="headerlink" title="线程池类定义"></a>线程池类定义</h5><p>线程处理函数和运行函数设置为私有属性</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">threadpool</span>&#123;</span><br><span class="line">     <span class="keyword">public</span>:</span><br><span class="line">         <span class="comment">//thread_number是线程池中线程的数量</span></span><br><span class="line">         <span class="comment">//max_requests是请求队列中最多允许的、等待处理的请求的数量</span></span><br><span class="line">         <span class="comment">//connPool是数据库连接池指针</span></span><br><span class="line">         <span class="built_in">threadpool</span>(connection_pool *connPool, <span class="type">int</span> thread_number = <span class="number">8</span>, <span class="type">int</span> max_request = <span class="number">10000</span>);</span><br><span class="line">         ~<span class="built_in">threadpool</span>();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//像请求队列中插入任务请求</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">append</span><span class="params">(T* request)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="comment">//工作线程运行的函数</span></span><br><span class="line">        <span class="comment">//它不断从工作队列中取出任务并执行之</span></span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">void</span> *<span class="title">worker</span><span class="params">(<span class="type">void</span> *arg)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="comment">//线程池中的线程数</span></span><br><span class="line">        <span class="type">int</span> m_thread_number;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//请求队列中允许的最大请求数</span></span><br><span class="line">        <span class="type">int</span> m_max_requests;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//描述线程池的数组，其大小为m_thread_number</span></span><br><span class="line">        <span class="type">pthread_t</span> *m_threads;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//请求队列</span></span><br><span class="line">        std::list&lt;T *&gt;m_workqueue;    </span><br><span class="line"></span><br><span class="line">        <span class="comment">//保护请求队列的互斥锁    </span></span><br><span class="line">        locker m_queuelocker;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//是否有任务需要处理</span></span><br><span class="line">        sem m_queuestat;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//是否结束线程</span></span><br><span class="line">        <span class="type">bool</span> m_stop;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//数据库连接池</span></span><br><span class="line">        connection_pool *m_connPool;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="线程池创建与回收"><a href="#线程池创建与回收" class="headerlink" title="线程池创建与回收"></a>线程池创建与回收</h5><p>构造函数中创建线程池,pthread_create函数中将类的对象作为参数传递给静态函数(worker),在静态函数中引用这个对象,并调用其动态方法(run)。</p>
<p>具体的，类对象传递时用this指针，传递给静态函数后，将其转换为线程池类，并调用私有成员函数run。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">threadpool&lt;T&gt;::<span class="built_in">threadpool</span>( connection_pool *connPool, <span class="type">int</span> thread_number, <span class="type">int</span> max_requests) : <span class="built_in">m_thread_number</span>(thread_number), <span class="built_in">m_max_requests</span>(max_requests), <span class="built_in">m_stop</span>(<span class="literal">false</span>), <span class="built_in">m_threads</span>(<span class="literal">NULL</span>),<span class="built_in">m_connPool</span>(connPool)&#123;</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">if</span>(thread_number&lt;=<span class="number">0</span>||max_requests&lt;=<span class="number">0</span>)</span><br><span class="line">         <span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line"> </span><br><span class="line">     <span class="comment">//线程id初始化</span></span><br><span class="line">     m_threads=<span class="keyword">new</span> <span class="type">pthread_t</span>[m_thread_number];</span><br><span class="line">     <span class="keyword">if</span>(!m_threads)</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;thread_number;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//循环创建线程，并将工作线程按要求进行运行</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">pthread_create</span>(m_threads+i,<span class="literal">NULL</span>,worker,<span class="keyword">this</span>)!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">delete</span> [] m_threads;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将线程进行分离后，不用单独对工作线程进行回收</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">pthread_detach</span>(m_threads[i]))&#123;</span><br><span class="line">            <span class="keyword">delete</span>[] m_threads;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="向请求队列中添加任务"><a href="#向请求队列中添加任务" class="headerlink" title="向请求队列中添加任务"></a>向请求队列中添加任务</h5><p>通过list容器创建请求队列，向队列中添加时，通过互斥锁保证线程安全，添加完成后通过信号量提醒有任务要处理，最后注意线程同步。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> threadpool&lt;T&gt;::<span class="built_in">append</span>(T* request)</span><br><span class="line">&#123;</span><br><span class="line">    m_queuelocker.<span class="built_in">lock</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//根据硬件，预先设置请求队列的最大值</span></span><br><span class="line">    <span class="keyword">if</span>(m_workqueue.<span class="built_in">size</span>() &gt; m_max_requests)</span><br><span class="line">    &#123;</span><br><span class="line">        m_queuelocker.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//添加任务</span></span><br><span class="line">    m_workqueue.<span class="built_in">push_back</span>(request);</span><br><span class="line">    m_queuelocker.<span class="built_in">unlock</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//信号量提醒有任务要处理</span></span><br><span class="line">    m_queuestat.<span class="built_in">post</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="线程处理函数"><a href="#线程处理函数" class="headerlink" title="线程处理函数"></a>线程处理函数</h5><p>内部访问私有成员函数run，完成线程处理要求</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="run执行任务"><a href="#run执行任务" class="headerlink" title="run执行任务"></a>run执行任务</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>






      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/02/10/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E5%B0%81%E8%A3%85%E7%B1%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Wang Wenhui">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gray's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Gray's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/02/10/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E5%B0%81%E8%A3%85%E7%B1%BB/" class="post-title-link" itemprop="url">线程同步机制封装类</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-02-10 16:07:51 / 修改时间：20:35:51" itemprop="dateCreated datePublished" datetime="2023-02-10T16:07:51+08:00">2023-02-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/TinyWebServer/" itemprop="url" rel="index"><span itemprop="name">TinyWebServer</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
	<div>
		
	</div>
    <div class="post-body" itemprop="articleBody">
          <h1 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="RAII"><a href="#RAII" class="headerlink" title="RAII"></a>RAII</h3><p>全称：Resource Acquisition is Initialization 即资源获取即初始化</p>
<p>用类来管理资源，将资源和对象的生命周期绑定（通过构造和析构函数）</p>
<p>核心思想是将资源或者状态与对象的声明周期绑定，通过C++的语言机制，实现安全管理，智能指针就是最好的例子</p>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>信号量是一种特殊的变量，只能取自然数值并且只支持两种操作：等待(P)和信号(V),假设有信号量SV，对它的P，V操作如下：<br>    P，如果SV的值大于0，则将其减一；若SV的值为0，则挂起执行<br>    V，如果有其他进程因为等待SV而挂起，则唤醒；若没有，则将SV值加一</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sem<span class="emphasis">_init函数用于初始化一个未命名的信号量</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">sem_</span>destory函数用于销毁信号量</span><br><span class="line"></span><br><span class="line">sem<span class="emphasis">_wait函数将以原子操作方式将信号量减一,信号量为0时,sem_</span>wait阻塞</span><br><span class="line"></span><br><span class="line">sem<span class="emphasis">_post函数以原子操作方式将信号量加一,信号量大于0时,唤醒调用sem_</span>post的线程</span><br></pre></td></tr></table></figure>

<p>以上函数，成功返回0，失败返回errno</p>
<h3 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h3><p>互斥锁，也称互斥量，可以保护关键代码段，以确保独占式访问。当进入关键代码段，获得互斥锁将其加锁；离开关键代码段，唤醒等待该互斥锁的线程</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pthread<span class="emphasis">_mutex_</span>init函数用于初始化互斥锁</span><br><span class="line"></span><br><span class="line">pthread<span class="emphasis">_mutex_</span>destory函数用于销毁互斥锁</span><br><span class="line"></span><br><span class="line">pthread<span class="emphasis">_mutex_</span>lock函数以原子操作方式给互斥锁加锁</span><br><span class="line"></span><br><span class="line">pthread<span class="emphasis">_mutex_</span>unlock函数以原子操作方式给互斥锁解锁</span><br></pre></td></tr></table></figure>

<p>以上函数，成功返回0，失败返回errno</p>
<h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><p>条件变量提供了一种线程间的通知机制，当某个共享数据达到某个值时，唤醒等待这个共享数据的线程</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pthread<span class="emphasis">_cond_</span>init函数用于初始化条件变量</span><br><span class="line"></span><br><span class="line">pthread<span class="emphasis">_cond_</span>destory函数销毁条件变量</span><br><span class="line"></span><br><span class="line">pthread<span class="emphasis">_cond_</span>broadcast函数以广播的方式唤醒所有等待目标条件变量的线程</span><br><span class="line"></span><br><span class="line">pthread<span class="emphasis">_cond_</span>wait函数用于等待目标条件变量.该函数调用时需要传入 mutex参数(加锁的互斥锁) ,函数执行时,先把调用线程放入条件变量的请求队列,然后将互斥锁mutex解锁,当函数成功返回为0时,互斥锁会再次被锁上. 也就是说函数内部会有一次解锁和加锁操作.</span><br></pre></td></tr></table></figure>

<h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>锁机制：<br>    实现多线程同步，通过锁机制，确保任一时刻只能有一个线程能进入关键代码段</p>
<p>封装：<br>    将锁的创建和销毁封装在类的构造与析构函数中，实现RAII机制</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">sem</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="built_in">sem</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//信号量初始化</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">sem_init</span>(&amp;m_m_sem,<span class="number">0</span>,<span class="number">0</span>) != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line">            &#125;</span><br><span class="line">		&#125;</span><br><span class="line">    </span><br><span class="line">    	~<span class="built_in">sem</span>()</span><br><span class="line">        &#123;</span><br><span class="line">			<span class="built_in">sem_destory</span>(&amp;m_sem);</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">    	<span class="type">sem_t</span> m_sem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将重复代码封装为函数，减少代码的重复</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span>   <span class="comment">//条件变量的使用机制需要配合锁来使用</span></span><br><span class="line"> <span class="number">2</span>   <span class="comment">//内部会有一次加锁和解锁</span></span><br><span class="line"> <span class="number">3</span>   <span class="comment">//封装起来会使得更加简洁</span></span><br><span class="line"> <span class="number">4</span>   <span class="function"><span class="type">bool</span> <span class="title">wait</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> 5   </span>&#123;</span><br><span class="line"> <span class="number">6</span>       <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"> <span class="number">7</span>       <span class="built_in">pthread_mutex_lock</span>(&amp;m_mutex);</span><br><span class="line"> <span class="number">8</span>       ret = <span class="built_in">pthread_cond_wait</span>(&amp;m_cond,&amp;m_mutex);</span><br><span class="line"> <span class="number">9</span>       <span class="built_in">pthread_mutex_unlock</span>(&amp;m_mutex);</span><br><span class="line"><span class="number">10</span>       <span class="keyword">return</span> ret == <span class="number">0</span>;</span><br><span class="line"><span class="number">11</span>   &#125;</span><br><span class="line"><span class="number">12</span>   <span class="function"><span class="type">bool</span> <span class="title">signal</span><span class="params">()</span></span></span><br><span class="line"><span class="function">13   </span>&#123;</span><br><span class="line"><span class="number">14</span>       <span class="keyword">return</span> <span class="built_in">pthread_cond_signal</span>(&amp;m_cond) == <span class="number">0</span>;</span><br><span class="line"><span class="number">15</span>   &#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/02/08/RPC%E6%A1%86%E6%9E%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Wang Wenhui">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gray's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Gray's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/02/08/RPC%E6%A1%86%E6%9E%B6/" class="post-title-link" itemprop="url">RPC框架</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-02-08 22:24:52 / 修改时间：23:11:22" itemprop="dateCreated datePublished" datetime="2023-02-08T22:24:52+08:00">2023-02-08</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
	<div>
		
	</div>
    <div class="post-body" itemprop="articleBody">
          <p>RPC	Remote Procedure Calls	远程函数调用<br>需要解决的问题</p>
<ol>
<li>函数映射</li>
<li>数据转换成字节流</li>
<li>网络传输</li>
</ol>
<h2 id="分层设计"><a href="#分层设计" class="headerlink" title="分层设计"></a>分层设计</h2><h2 id="关键指标"><a href="#关键指标" class="headerlink" title="关键指标"></a>关键指标</h2><ol>
<li>稳定性</li>
<li>易用性</li>
<li>扩展性</li>
<li>观测性</li>
<li>高性能</li>
</ol>
<h3 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h3><p>熔断：保护调用方，防止被调用的服务出现问题而影响到整个链路<br>限流：保护被调用方，防止大流量把服务压垮<br>超时控制：避免浪费资源在不可用节点上</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Wang Wenhui</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  





  





<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
